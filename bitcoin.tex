%
% 6722
%
\documentclass[12pt]{book}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[dvips]{graphicx}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{latexsym}
\usepackage{makeidx}
\usepackage{verbatim}

\newcommand{\complex}{\Bbb C}
\newcommand{\curl}{\nabla \times}
\renewcommand{\div}{\nabla \cdot}
\newcommand{\Dal}{\Box}
\newcommand{\nextline}{\\}
\newcommand{\breakline}{\\}
\newcommand{\grad}{\nabla}
\newcommand{\reals}{\Bbb R}
\newcommand{\tr}{\mbox{tr}}
\newcommand{\qed}{$\Box$}


%
% htex commands for images, links, and code
%
\newcommand{\img}[2]{\begin{center}\includegraphics[width=#2]{#1.eps}\end{center}}
\newcommand{\link}[2]{\href{#1}{#2}}
\newcommand{\insertcode}[1]{{\footnotesize \verbatiminput{#1}}}
\newcommand{\html}[1]{}
\newcommand{\latexorhtml}[2]{#1}

%
% Special chapter commands, so htex can construct headers and table
% of contents
%
\newcommand{\frontchapter}[3]{\chapter*{#1}}
\newcommand{\mainchapter}[3]{\chapter{#1}}
\newcommand{\backchapter}[3]{\chapter*{#1}}




\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}


\DefineVerbatimEnvironment{bash}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{pseudocode}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{python}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{text}{Verbatim}{fontsize=\small}

\newcounter{exercise}[chapter]
\renewcommand\theexercise{\thechapter.\arabic{exercise}}

\newenvironment{singlespace}{\renewcommand{\baselinestretch}{1}}

\newenvironment{exercise}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{exercises}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}


\newcommand{\problemheader}{\vspace{5mm} \noindent \textbf{\Large \!\!
    Problems}}

\newcounter{problem}[chapter]
\renewcommand\theproblem{\thechapter.\arabic{problem}}

\newenvironment{problem}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{problems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{myproblem}[chapter]
\renewcommand\themyproblem{\thechapter.\arabic{myproblem}}

\newenvironment{myproblems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@myproblem\themyproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem for the author
                        \refstepcounter{myproblem}\themyproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{request}[chapter]
\renewcommand\therequest{\thechapter.\arabic{request}}

\newenvironment{request}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@request\therequest}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Question to readers
                        \refstepcounter{request}\therequest:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{mycomment}[chapter]
\renewcommand\themycomment{\thechapter.\arabic{mycomment}}

\newenvironment{mycomments}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@mycomment\themycomment}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Comment for the author
                        \refstepcounter{mycomment}\themycomment:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{example}[chapter]
\renewcommand\theexample{\thechapter.\arabic{example}}

\newenvironment{examples}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@example\theexample}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Example
                        \refstepcounter{example}\theexample:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\DefineVerbatimEnvironment{myverbatim}{Verbatim}{fontsize=\small}


\makeindex

\begin{document}

\title{Beyond Bitcoin}
\author{Michael Nielsen\thanks{Email: mn@michaelnielsen.org}$^{,}$\thanks{Web: http://michaelnielsen.org/}}
\date{\today}

\maketitle

\pagestyle{headings}
\pagenumbering{roman}

\tableofcontents

\chapter{How Bitcoin actually works}

%
% what I do in this article
%
This article explains how Bitcoin works.  Of course, thousands of
articles ``explaining'' Bitcoin have been written.  Most are
superficial explanations, giving vague accounts of the underlying
cryptographic ideas, and often glued together with an account of the
Bitcoin soap opera -- ``Is it a bubble?'', ``Who's getting rich?'',
and so on.  Some articles delve deeper into the technical details, but
often gloss over crucial points.  Even the
\link{http://bitcoin.org/bitcoin.pdf}{original paper} introducing
Bitcoin was vague on key points.  My aim in this article is to present
all the major ideas behind the Bitcoin protocol in a clear,
comprehensible way.

%
% this all sounds like hard work
%
Of course, understanding the protocol is hard work.  It is tempting to
take Bitcoin as given, and instead engage in speculation about how to
get rich with Bitcoin, whether Bitcoin is a bubble, whether it means
the end of taxation, and so on.  That's fun, but severely limits your
understanding of Bitcoin.  Understanding the details of the protocol
opens up otherwise inaccessible vistas.  The ideas behind Bitcoin can
be used to create many new types of financial instrument; those, in
turn, have the potential to create new forms of collective human
behaviour.  

%
% What you need as background
%
As background, I assume you're comfortable with
\link{http://en.wikipedia.org/wiki/Public-key_cryptography}{public key
  cryptography}, and with the closely related idea of
\link{https://en.wikipedia.org/wiki/Digital_signature}{digital
  signatures}.  I'll also assume you're familiar with
\link{https://en.wikipedia.org/wiki/Cryptographic_hash_function}{cryptographic
  hashing}.  None of this is especially difficult.  It can be taught
in freshman university mathematics or computer science classes.  The
ideas are beautiful, so if you're not familiar with them, I recommend
taking a few hours to get familiar.  You can learn it from XXX.

%
% why does Bitcoin involve so much cryptography
%
It may be surprising that Bitcoin's basis is cryptography.  After all,
it appears to be about finances and money, not sending secret
messages.  But the problems that need to be solved to make Bitcoin
work are largely about securing transactions -- making sure people
can't steal from one another, that one person can't impersonate
another, and so on.  In the world of atoms we achieve this security
with devices such as locks, safes, bank vaults and security guards.
In the digital world this is the job of cryptography.  And that's why
Bitcoin is essentially a cryptographic protocol.

\section{Rediscovering Bitcoin}

We'll begin by designing a very simple digital currency.  To
distinguish it from Bitcoin we'll call this simple currency
\emph{Infocoin}.  We'll then criticise Infocoin, and find a way of
improving the currency.  Through several iterations of this process,
we'll build up all the ideas that go into the full Bitcoin protocol.
In a sense we'll rediscover Bitcoin.

This iterative approach is more work to read than if I explained the
entire Bitcoin protocol in one shot, up-front.  But while you could
understand the mechanics of Bitcoin that way, it would be difficult to
understand why all the elements of Bitcoin are the way they are.  It'd
be like memorizing a long cooking recipe, without understanding why
the recipe is put together the way it is.  The advantage of the
iterative explanation is that you can see piece by piece how the
elements of Bitcoin are built up.

\section{A signed letter of intent}

So how can we design a digital currency?  The goal is for Alice to be
able to transfer money to Bob, simply by transmitting a string of bits
-- her Infocoin.

I must admit that when I first heard about digital money, I thought it
sounded impossible.  If Alice can use a string of bits as money, how
can we prevent Alice from using the same bit string over and over,
thus minting an infinite supply of money for herself?  And how can we
prevent Bob or someone else forging such strings of bits, effectively
stealing from Alice?

These are just two of the many problems that need to be overcome in
order to use information as currency.

Let's address one of these problems.  Let's find a way to prevent
someone else forging such a string, and thus stealing from Alice.  To
do this, Alice writes down the message "I, Alice, am giving Bob one
Infocoin".  She then signs the message using her private key and
announces the signed string of bits to the entire world.

This achieves two things.  First, anyone in the world (including Bob)
can then use Alice's public key to verify that Alice really did sign
the message "I, Alice, am giving Bob one Infocoin".  This establishes
that Alice truly intends to give Bob one Infocoin.

Second, this gives Alice at least a limited protection from forgery,
since only Alice has the private key used to sign the message.  Of
course, once Alice has published her message it's possible for other
people to duplicate the message, so in that sense forgery is possible.
But before that initial act of publication, there's no way someone
else can forge that bit string; the initial construction can only be
done by Alice!  

To put this in a slightly different way, suppose someone encounters
the signed message ``I, Alice, am giving Bob one Infocoin''.  If they
verify the signature, then they know that at some point Alice did sign
that message.

XXX --- what's the digital money here?  It's just the message itself:
the digitally signed ``XXX''.  This will remain true in more elaborate
protocols as well --- the digital money will just be more and more
elaborate messages (with a surrounding protocol for all parties to
agree on the transaction).

\textbf{A note on analysing protocols such as Bitcoin:} Before we get
into an analysis of this protocol, a word on how to think about
cryptographic protocols.  Such protocols often have many problems --
in the context of digital money, that means multiple ways in which
people can cheat, forge money, steal money, and so on.  It's easy to
become overwhelmed by all the problems, and to think that you need to
look for a silver bullet solution which solves all the problems at
once.  This makes it difficult to think clearly about the protocol.

A better way to proceed is to concentrate on just one or two problems
at a time, and to ignore all other issues.  That's what we'll do.  At
each stage I'll identify just one or two problems, and then introduce
one or two simple ideas that solve that problem or problems.  Then
we'll do this over again, identifying a problem and a solution,
repeating this pattern several times, as we gradually build up the
protocol.

As we go through this process you'll likely have many thoughts about
(often glaring) holes in the protocol-of-the-moment.  You'll have to
trust that I will eventually resolve all those problems!  To build
confidence, I suggest keeping notes as you go -- if something's
bugging you, then pause in your reading, and write down as clearly as
posssible what's bugging you.  Don't worry about resolving the problem
immediately, just keep a record.  When you finally understand the
entire protocol, revisit your list, and see if the problem has been
addressed.

XXX - How to read crypto.  More generally, reading cryptography is
difficult work.  You certainly can't read it quickly, likely a novel.
But you can't even read it somewhat more slowly, as you might read a
conventional technical document.  Cryptographic protocols tend to be a
bit like puzzles, with interlocking parts put very carefully put
together.  To really understand them you need to examine all those
connections carefully, looking at them from many difficult angles, and
gradually getting to the point that it's all in your head at once.
That's tough work, but, as with a well-designed puzzle, there is also
a beauty to it, once you get the entirety of the protocol inside your
head, and understand how all the parts relate.

\section{Using serial numbers to make coins unique}

Alright, let's return to Protocol 0, the one where Alice simply
digitally signs her intent to transfer an Infocoin to Bob.  A problem
with this protocol is that Alice could keep sending Bob the same
signed message over and over.  Suppose Alice sent the signed message
"I, Alice, am giving Bob one Infocoin" ten times.  Does that mean
Alice sent Bob ten \emph{different} Infocoins?  Was her message
accidentally duplicated?  Worse, perhaps she was trying to trick Bob
into believing that she had given him ten different Infocoins, when
the message only proves to the world that she intends to transfer one
Infocoin.

What we'd like is a way of making Infocoins unique.  They need a label
or serial number.  Alice would sign the message "I, Alice, am giving
Bob one Infocoin, with serial number 8740348".  Then, later, Alice
could sign the message "I, Alice, am giving Bob one Infocoin, with
serial number 8770431", and Bob (and everyone else) would know that
that this was a \emph{different} Infocoin that was being transferred.

I haven't yet said where Alice would get the serial numbers from.
Should she just make them up out of thin air?  Obviously, that'd be
convenient for her -- she'd have the capacity to print money!  And
we'd still have the problem that there's nothing to prevent her from
spending a coin with the same serial number twice.

One way to solve this problem is to introduce a \emph{bank} which is
the ultimate source of Infocoins.  This bank provides serial numbers,
keeps track of who has which Infocoins, and verifies that transactions
really are legitimate, preventing Alice from making up serial numbers
of her own.

In more detail, let's suppose Alice goes into the bank, and says "I
want to withdraw one Infocoin from my account".  The bank reduces her
account balance by one Infocoin, and gives her a new, never-before
used serial number, let's say 1234567.

Then, when Alice wants to transfer an Infocoin to Bob, she'd sign the
message "I, Alice, am giving Bob one Infocoin, with serial number
1234567".  But Bob doesn't just accept the Infocoin.  Instead, he
contacts the bank, and verifies that: (a) the Infocoin with that
serial number belongs to Alice; and (b) Alice hasn't already spent the
Infocoin.  If both those things are true, then Bob accepts the
Infocoin, and the bank updates their records to show that the Infocoin
with that serial number is now in Bob's possession, and no longer
belongs to Alice.

\section{Getting rid of the bank}

This last solution looks pretty good.  It's still got many problems --
problems like how to authenticate the identities of Alice, Bob and the
bank -- but it doesn't seem like much of a stretch to believe that
that with some further thought we could overcome those problems.

However, it turns out that we can do something much more ambitious.
We can actually eliminate the bank from the protocol.  This changes
the nature of the currency considerably, since a single organization
is no longer in charge.  XXX --- Why should we care?  Should we care?

The idea is to make it so \emph{everyone} is the bank.  In particular,
we'll assume that everyone using Infocoin keeps a complete record of
which Infocoins belong to which person.  You can think of this as
being like a ledger showing all transactions.  We'll call this ledger
the \emph{block chain}, since that's what the complete record will be
called in Bitcoin, once we get to it.

Now, suppose Alice wants to transfer an Infocoin to Bob.  She signs
the message "I, Alice, am giving Bob one Infocoin, with serial number
1234567", and gives the signed message to Bob.  Bob can use his copy
of the block chain to check that, indeed, the coin is Alice's to give.
If that checks out then he can broadcast both Alice's message and his
acceptance of the transaction to the entire network, and everyone will
update their copy of the block chain.

There is, however, a problem with this.  Suppose Alice wants to cheat
by double spending her Infocoin.  She sends the signed message ``I,
Alice, am giving Bob one Infocoin, with serial number 1234567'' to
Bob, and the message``I, Alice, am giving Charlie one Infocoin, with
serial number 1234567'' to Charlie.  Both Bob and Charlie use their
block chain to verify that the Infocoin is Alice's to spend.  In both
cases it checks out, and they each broadcast their acceptance of the
transaction (and Alice's signed messages).  How then should other
people update their block chains?  Even if everyone can agree on a
consistent way to update their block chains, so everyone agrees on who
has which Infocoins, there is still the problem that either Bob or
Charlie will be cheated.

Now, at first this seems like it would be difficult for Alice to pull
off.  After all, if Alice sends the message first to Bob, then Bob can
quickly verify it, and then tell everyone else in the network
(including Charlie) to update their block chain.  Once that has
happened, Charlie would no longer be fooled by Alice. So there is only
a narrow window of time in which Alice can double spend.  However,
it's undesirable to have such a window of time.  Worse, there are
things Alice could do to make that window broader.  She could, for
example, look for times when Bob and Charlie are likely to have a lot
of latency in communication, perhaps by doing internet traffic
analysis, or maybe by deliberately trying to disrupt communications.
If she can slow down communication even a little that makes her task
of double spending significantly easier.

How can we address the problem of double spending?  The obvious
solution is that when Alice sends Bob an Infocoin, Bob shouldn't try
to verify the transcation alone.  Rather, he should broadcast the
possible transaction to the entire network of Infocoin users, and ask
them to help determine whether the transaction is legitimate.  If they
collectively decide that the transaction is okay, then Bob can accept
the Infocoin, and everyone will update their block chain
appropriately.

That's a good high level description.  How would it work in detail?
Our goal is to find a procedure that: (1) guarantees that the network
can collectively resolve any ambiguity in the block chain; and (2) the
resolution won't allow anyone to be cheated.

Let's suppose Alice wants to give Bob an Infocoin.  As before, she
signs the message "I, Alice, am giving Bob one Infocoin, with serial
number 1234567", and gives the signed message to Bob.  Also as before,
Bob does a basic sanity check, using his copy of the block chain to
check that, indeed, the coin is Alice's to give.  But at that point
things differ.  He doesn't just go ahead and accept the transaction at
this point.  Instead, he broadcast Alice's message to the entire
network.  Other members of the network check to see whether Alice
does, in fact, have that Infocoin to give Bob.  If so, then they
broadcast out the message "Yes, Alice does have Infocoin 1234567, it
can now be transferred to Bob.''  Once enough people have broadcast
that message, everyone updates their block chain to show that Infocoin
1234567 now belongs to Bob, and the transaction is complete.

Note, incidentally, that I've left this protocol somewhat vague.  For
instance, what does it mean to say ``once enough people have broadcast
that message''?  What does ``enough'' mean?  How does everyone agree
on this?  I'm going to leave this a little vague for now.  In the next
section I'm going to point out a serious problem with this approach.
We'll fix the problem, and in the process make the ideas above both
better, and also more specific.


\section{Proof-of-work}

A problem with this protocol has to do with the honesty of network
users.  Suppose Alice wants to double spend.  She could use an
automated automated system to set up a large number of separate
identities on the Infocoin network. 

 He could then steal from Alice by
broadcasting out to the network the message "I, Alice, am giving Bob
one InfoCoin, with serial number 1234567".  Then he could swamp the
network with messages saying ``Yes, this is a leg

We can solve this problem using an idea known as \emph{proof-of-work}.
The idea is that third parties will have to do some work -- basically,
they have to solve a computational puzzle -- to take part in the
approval process.  This sounds crazy.  Why make it hard to help in the
approval process?  But it turns out to have a really good result: it
makes it very unlikely that anyone will try to impersonate a million
people on the network, since they'd need to solve a million puzzles,
and that will cost them real money.

In more detail, here's how it works.

Suppose Alice broadcasts to the network the news that "I, Alice, am
giving Bob one Infocoin, with serial number 1234567".  

As other people hear the message, they add it to a queue of pending
transactions that they've been told about, but which haven't yet been
approved by the network.  For instance, a third party named Charlie
might have the following queue of pending transactions:

I, Tom, am giving Sue one Infocoin, with serial number 1201174

I, Sydney, am giving Cynthia one Infocoin, with serial number 1295618

I, Alice, am giving Bob one Infocoin, with serial number 1234567

Charlie checks his ledger, and can see that each of the transactions
are valid.  He would \emph{like} to help out by broadcasting the
validity to the entire network.  But, unfortunately, the rest of the
network doesn't know whether or not to trust Charlie.

So here's the puzzle Charlie has to solve.  He takes his entire list
of pending transactions.  He appends to that list of transactions a
number of his choice, let's denote it $x$, and then hashes the list of
transactions plus $x$ to produce a hash value:

XXX

The puzzle Charlie has to solve -- the proof-of-work -- is to find a
number $x$ so that the output hash ends with a long string of zeroes:

XXX

This is \emph{hard} to do.  The reason it's hard is because the output
from a (good) cryptographic hash functions is supposed to behave more
or less like a random number.  So if we want the output hash value to
finish with 10 zeroes, say, then Charlie will need to try something
like $16^{10} \approx 10^{12}$ different values for $x$ before he.

If Charlie should happen to find such an $x$ then (celebration!)  he
broadcasts the list of transactions he's approving to the network,
together with the value for $x$.  Other participants in the Infocoin
network can verify that $x$ is a valid solution to the proof-of-work
puzzle.  And they then update their block chains to reflect the new
transactions.


chooses a random number as well; called
a \emph{nonce}.  Just to be concrete, lets suppose he chooses the
nonce XXX.  Then he hashes the list of transactions together with the
nonce to produce a hash value:


It's a bit like having a lottery to approve transactions.  But each
ticket in the lottery costs a little bit of computing power.  If
millions of people are entering, then Charlie would only have a very
small chance to corrupt the process, unless he expends enormous (and
very costly) computational resources.

\section{Reward for work, and the origin of Infocoins}

A problem with proof-for-work is that while it's all very well to ask
Charlie to work hard to validate a transaction, why would he bother to
do so, expending computational power; power that costs him real money;
merely to help validate other people's transactions?  And if he's not
willing to expend that power, then the whole system falls apart --
there is no reason for an honest participant to

The solution to this problem is to reward the people who help find the
proof-of-work.  In particular, suppose we credit whoever validates the
block with some Infocoins.  Provided the Infocoin reward is large
enough that gives them an incentive to participate in the mining.

Of course, this gives rise to many economic questions.  It changes the
total supply of Infocoins.  And it sets up interesting economics
around mining.  Does Infocoin mining end up in concentrated in the
hands of a few, or many?  If it's just a few, doesn't that endanger
the security of the system?  We'll look at these questions below in
the context of Bitcoin.  


\end{document}


What ideas do I want to add?


XXX: MODIFICATION: Modify by replacing the serial number by a pointer
to the previous transaction.

Modifications: not everyone needs to have a copy of the block chain.


<h3>Why have a chain?</h3>

<div class="section">

Why have a chain?


Why point 

To approve the 

In particular, they actually have to solve a difficult puzzle before
they can approve a transaction.



when a potential transaction is broadcast



Make it take constant time.


CHEATING: WORK VERY HARD TO 

</div>


<h3>Bitcoin</h3>

Alright, we've now understood the main ideas behind BitCoin.  Let's
move away from InfoCoin, and describe the actual BitCoin protocol.

You install a wallet program on your computer.

Suppose someone wants to buy something from you; maybe you're a
merchant who has set up an online store, and you allow people to pay
using Bitcoin.

Well, you first tell your wallet to generate a private key / public
key pair.  Then your wallet generates a <em>Bitcoin address</em>: this
is just a hashed version of the public key:

XXX

You then send your Bitcoin address to the person who wants to send you
Bitcoins:

XXX

This is quite safe -- after all, it's a hash of your public key, which
is intended to be known by the world, anyway.  (I'll return later to
the use of the hash.)

They [XXX] then generate a <em>transaction</em>.  Let's take a look at
the raw data from an <a
href="http://blockexplorer.com/tx/7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9">actual
transaction</a> transferring $0.31900000$ (XXX) bitcoins.  I've added
line numbers, for ease of reference in the explanation below, but
otherwise this all the data in the transaction.

<pre>
1.  {"hash":"7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9",
2.  "ver":1,
3.  "vin_sz":1,
4.  "vout_sz":1,
5.  "lock_time":0,
6.  "size":224,
7.  "in":[
8.    {"prev_out":
9.      {"hash":"2007aec728a1b1dcd36aa476e873926c412e94b2d16d060a7c97014b83a00c3e",
10.      "n":0},
11.    "scriptSig":"304502205014856cdf89da70ad9a4f223bac4e5477da5c6cb69ef2b9f8b5f8548e21307e0221009bfe2698f1eb1c561f41981d8e78c11d9e685a70e682f144ee6c8ab5ecb0497c01 042b2d8def903dd62d0c4161ed8d4ccfa5967e11a28e65cb141235b7c27d8ef6aa3bd63be077323cf3d7e0e8895b264b94feb4b40478b431da6f45dfc8e1004f62"}],
12. "out":[
13.   {"value":"0.31900000",
14.    "scriptPubKey":"OP_DUP OP_HASH160 a7db6ff121871c65a8924b8e40f160d385515ad7 OP_EQUALVERIFY OP_CHECKSIG"}]}
</pre>

<p>
Let's go through this, line by line.
</p>

<p>
Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.
</p>

<p>
Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.
</p>

<p>
Lines 3 and 4 tell us that the transaction has one input and one
output, respectively.  I'll talk below about transactions with more
inputs and outputs, and why that's useful.
</p>


<p>
Line 5 is a detail.  It contains the value for <code>lock_time</code>,
which can be used to control when a transaction is finalized.  In this
case, as for most Bitcoin transactions being carried out today, the
<code>lock_time</code> is set to 0, which means the transaction is
finalized immediately.
</p>

<p>
Line 6 is also a detail, telling us the size (in bytes) of the
transaction.  The important thing here is to understand that this
<em>isn't</em> the monetary amount being transferred!  That comes
later.
</p>

<p>
Lines 7 through 11 defines the input to the transaction.  In
particular, lines 8 through 10 tell us that the input is to be taken
from the ouput from an earlier transaction, with the given
<code>hash</code>.  The <code>n=0</code> tells us it's to be the first
output from that transaction; we'll see soon how multiple
outputs (and inputs) from a transaction work, so don't worry too much
about this for now.  Line 11 contains the signature, followed by a
space, and then the public key of the person sending the money.  Note
that the signature is for the data in lines 8 through 10.
</P>

<p>
Lines 12 through 14 define the output from the transaction.  In
particular, line 13 tells us the value of the output, 0.39000000
bitcoins, or 39,000,000 satoshis.  Line 14 is somewhat complicated.
The main thing, however, is that the long string "a7db6ff12..." is the
Bitcoin address of the intended recipient of the funds.
</P>


<h3>Transactions with multiple inputs and outputs</h3>

I described above how a transaction with just a single input and a
single output works.

In practice, it's often extremely convenient to create Bitcoin
transactions with multiple inputs or multiple outputs.

For example, suppose I want to send you else 150 satoshis.  They do so
by spending money from a previous transaction in which they received
200 satoshis.  Of course, they don't want to send the entire 200
satoshis to the other person.  The solution is to send the other
person 150 satoshis, and to send one of their own Bitcoin addresses 50
satoshis.  Those 50 satoshis are known as <em>change</em>.  Of course,
it differs a little from ordinary change, since change is what you pay
yourself.




The second output is defined lines 23 and 24, with a similar format to
the first output.

The sum of all the inputs must be equal to the sum of all the outputs.

If not...XXX.  Transaction fee.


We can visualize the entire transaction content as follows:

XXX



Here's the raw data from an <a
href="http://blockexplorer.com/tx/99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f">actual
transaction</a>.  I've added line numbers, for ease of reference in
the explanation below, but otherwise this all the data in the
transaction.

<pre>
1. {"hash":"99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f",
2. "ver":1,
3. "vin_sz":3,
4.  "vout_sz":2,
5.  "lock_time":0,
6.  "size":552,
7.  "in":[
8.    {"prev_out":{
9.      "hash":"3beabcb8818f8331dd8897c2f837a4f6fe5cc5e0f3a7c8806319402d2467c30a",
10.        "n":0},
11.     "scriptSig":"3044022062ea95519d5d91cbce4086a63b8cd509a4900ba59063b69286236527e31a228e022076de59315406b7ec3a7414c98b5d32f47d11b9a786d31cf44883f3fb5812aa4001 04c7d24c58ae83f38bd2fb496758ff544965d58e7e5471ccb7349c8c404c64d0a57b562a20dfdcf152e0a401473ba520e387bf2516a4841a5f5bf5701b6fc09552"},
12.    {"prev_out":{
13.        "hash":"fdae9b76f974a9476f81c52d5ae1fbbd48cb840722e0805e56de1f9d2da0d9bc",
14.        "n":0},
15.      "scriptSig":"304502201c08b87eec72c4cb77369da7ef108ac18f29a67dff8865163cac3b155a0e9bf4022100afd61ce024ed33c4eee5e2f5cbc13203527a3b708f14c9573943132c061f800301 026e15a0c21d5f8c708e8b86d2f57ab1b7d31afee4a479e30af29d705532cf59ce"},
16.    {"prev_out":{
17.        "hash":"20c86b709ff4747866ef9f59788d1e18de81956c6501854a15707ccaa11076ce",
18.        "n":1},
19.      "scriptSig":"3044022038203b996b306916848732679b320be3c511870249da5b03a719f5a1f39cf646022070fd8c34a6ff73ebc8272e5ba717b9d3ef7100846bdbe4049808683d475d478001 038a52383beaf9711915f338f9c063332f39443358c1e4bc942da69551093b0896"}],
20.  "out":[
21.    {"value":"0.01068000",
22.      "scriptPubKey":"OP_DUP OP_HASH160 e8c306229529009d596689cb9212d6519cf6de8a OP_EQUALVERIFY OP_CHECKSIG"},
23.    {"value":"4.00000000",
24.      "scriptPubKey":"OP_DUP OP_HASH160 d644e36b9b295b3a1fa6ca2f816ba1f9340f4806 OP_EQUALVERIFY OP_CHECKSIG"}]}
</pre>

Let's go through this, line by line.

Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.

Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.

Lines 3 and 4 tell us that the transaction has three inputs and two
outputs, respectively.

Line 5 is a detail.  It contains the value for <code>lock_time</code>,
which can be used to control when a transaction is finalized.  In this
case, as for most transactions today, the <code>lock_time</code> is
set to 0, which means the transaction is finalized immediately.

Line 6 tells us the size of the transaction.

Lines 7 through 19 define a list of the inputs to the transaction.
These are outputs from previous Bitcoin transactions.

The first input is defined in lines 8 through 11.  

In particular, lines 8 through 10 tell us that the input is to be
taken from the <code>n=0</code>th output from an earlier transaction,
with the given <code>hash</code>.  Line 11 contains the signature,
followed by a space, and then the public key of the person sending the
money.  Note that the signature is for the data in lines 8 through 10.

Lines 12 through 15 define the second input, with a similar format to
lines 8 through 11.  And lines 16 through 19 define the third input.

Lines 20 through 24 define a list containing the two outputs from the
transaction.

The first output is defined in lines 21 and 22.  Line 21 tells us the
value of the output, 0.01068000 bitcoins, or 1,068,000 satoshis.  Line
22 is somewhat complicated.  The main thing, however, is that the long
string "e8c30622..." is the Bitcoin address of the 

The second output is defined lines 23 and 24, with a similar format to
the first output.

The sum of all the inputs must be equal to the sum of all the outputs.

If not...XXX.  Transaction fee.

Suppose someone wants to send someone else 150 satoshis.  They do so
by spending money from a previous transaction in which they received
200 satoshis.  Of course, they don't want to send the entire 200
satoshis to the other person.  The solution is to send the other
person 150 satoshis, and to send one of their own Bitcoin addresses 50
satoshis.  Those 50 satoshis are known as <em>change</em>.  Of course,
it differs a little from ordinary change, since change is what you pay
yourself.

We can visualize the entire transaction content as follows:

XXX



Change.

<h3>Oddities of Bitcoin</h3>

Bitcoin has several oddities.

One oddity is the use of addresses.  Why not use the public key as the
address, rather than a hash of the public key?

This seems to be a fairly arbitrary design decision.  

One seemingly plausible explanation is that it's to add extra
security.  Even if the public key cryptosystem were broken, having
only hashed public keys public would still provide some level of
security.

Unfortunately, this story isn't especially plausible.  It's true that
to receive money, you only need reveal your Bitcoin address.  But to
spend money, you need to reveal your public key, since it's used to
sign the transaction.  Once you've revealed your public key, people
can take the hash to recover your address, and to see what previous
transactions it's participated in, as a recipient of funds.

In other words, your public key is kept secret


There is one scenario in which the use of addresses makes sense.
Suppose that the public key cryptography apocalypse occurs -- someone
discovers how to crack the public key cryptosystem.  Then everyone
whose public keys are known would immediately have their account
entirely compromised.  

Now, suppose that people never used the same Bitcoin address twice to
receive funds.

So provided you never use the same Bitcoin address twice

It's pretty common advice to  

A second oddity is that the transaction as a whole isn't signed.  XXX; TRANSACTION MALLEABILITY.




The transaction is labelled by a hash.  This is a hash of parts of the
remainder of the transaction.  It's not completely clear to me which
parts; apparently the transaction is somewhat malleable because of
this, but the amounts being paid out, senders and recipients can't be
changed.

A transaction actually doesn't have just one sender and receiver, but
can potentially involve many parties. 


Number of inputs.

Number of outputs.

Each input contains: (1) The hash of (part of) a previous transaction;
(2) an index for an output in that transaction; (3) the public key of
the sender; and (4) a signature for (part of) the transaction.



Each output contains: (1) The value for that output; (2) The hashed
public key of the intended recipient.

Note that the sum of the output values must equal the sum of the
inputs.

Why does it contain the hashed public key of the intended recipient?
I don't really quite get this.


Comment on the author: The paper is not especially well written.  It
contains a number of vague statements, and some <em>non
sequiturs</em>.  It looks to me most likely to be the work of someone
very bright, and very well informed, but probably not a long-time
professional.  It wouldn't surprise, though, if they were a graduate
student in the field, or had equivalent background.




How does Bitcoin relate to karma systems?


The dull questions:

+

The privacy premium.




Good questions: When it is economic to invest in Bitcoins?

What is the impact of having a fixed supply of money?


The economics of privacy.  

Will people pay a privacy premium?




This results in the growth of



What problem is proof of work solving?


The supply of money.  The Bitcoin addresses responsible for validating
the block receives a reward.  This reward is carried out as the first
transaction in the block.




Kickstarter at the protocol level


Generalized eminent domain


Anonymity?  Probably never.  The problem is that too much of the graph
is known.  Can always de-anonymize.  Might we hide steganographically?
Idea is to create a large number of transactions which swamp the
signal from the small number.

DDoS the Bitcoin network.  Simply start creating a very large number
of transactions.  This will overcome the network's ability to verify.
It wouldn't take a very large amount of power.



<h3>Problem: concentration of Bitcoin mining power in the hands of a
few</h3>

Consider what happens over time.  There's a good incentive to spend
more and more money.

Well, what happens at that point?  

It depends.  Suppose someone can apply ingenuity 

the problem is that, eventually, you'd expect
the cost of mining to .  You'd actually expect the number of pople

People switch their mining setups on and off, depending on the current
exchange rate.

You see this happening already.  

Rushes occur.


It's conventional to use uppercase Bitcoin when talking about general
aspects of Bitcoin.  So we'll talk about the Bitcoin protocol, the
Bitcoin foundation, and so on.  And to use lowercase bitcoin when
referring to specific denominations, as in "She sent 5 bitcoins to pay
for her order."

The name "Bitcoin" makes it sound as though a bitcoin is a
diminunitive unit of currency.  In fact, as I write a single bitcoin
trades for about 200 US dollars, and the exchange rate has in the past
gone nearly as high as 240 US dollars.  If Bitcoin were ever to go
truly mainstream I have little doubt the exchange rate would go much
higher.  And so a bitcoin isn't diminutive at all, it's big dollars.

In actual fact, the bitcoin isn't the basic unit of currency.  A
single bitcoin can be split up into 100 million "satoshis", named
after the originator of Bitcoin,
\link{https://en.bitcoin.it/wiki/Satoshi_Nakamoto}{Satoshi Nakamoto}.
If 200 US dollars is one bitcoin, then a satoshi is 1/500th of a US
cent.  

Bitcoin is the Wild West.  There's all sorts of shady behaviour and
hucksters looking to make a quick buck.  It's also true that, as in
the gold rush, it may be better to make money selling shovels than
digging for gold.  One oddity is that you'll read a lot of online
accounts by people who seem very knowledgeable and utterly confident
-- and who turn out to be completely wrong.  Sometimes this is
indicative of shady behaviour.  But more often it's just routine
over-confidence.  Don't believe everything you read.


\section{Why anonymity and untraceability?}

%
% why anonymity and untraceability?
%
Many Bitcoin fans make a big deal out of the relative anonymity and
difficulty of tracing Bitcoin.  What makes anonymity and
untraceability desirable in a currency?

The obvious reason a person might want anonymity and untraceability is
if they plan to do something illegal.  Online marketplaces such as
\link{https://en.wikipedia.org/wiki/Silk_Road_(marketplace)}{Silk
  Road}, \link{XXX}{XXX}, and \link{XXX}{XXX} use Bitcoin to make it
possible to buy and sell illegal drugs, XXX, XXX, and many other
illegal items and services.

Enabling this kind of crime is not a good argument in favour of
Bitcoin!  However, there is a better argument to be made.  Control
over currency gives a government power.  We see this, for example, in
the way the US State Department and other organizations
\link{https://en.wikipedia.org/wiki/WikiLeaks#U.S._diplomatic_cables_leak_responses}{put
  pressure on Wikileaks} by getting organizations such as PayPal and
MasterCard to freeze accounts owned by WikiLeaks.  Now, if you dislike
WikiLeaks this may not seem like such a bad thing.  But it's not
difficult to imagine variations on this which would be unequivocally
bad.  In the early 1990s, human rights groups in the Sudan had their
assets frozen, and in some cases confiscated, by an unfriendly
government.  Such examples suggest that a citizenry is safest if
government control over currency is minimized, except in the case of a
compelling interest.  One way of minimizing that control is make a
currency anonymous and untraceable.


ECONOMICS OF MINING: I don't think it's at all clear what the long-run
value of Bitcoin mining is.  It's a complicated problem.  What are the
tradeoffs involved in setting up an equilibrium?

Let's suppose the (appropriately amortized) cost of mining a bitcoin
is less than a bitcoin.  (There should be a risk premium, too.)

The equilibrium: 



Will effective banks still re-emerge?  What's the difference between a
marketplace / exchange and a bank, anyway?



The boostrapping problem in describing a currency.  When you write
about a currency such as Bitcoin there's an inherent oddity.  There's
always a point at which the description of the currency stops.

\end{document}