%
% 8809
%
\documentclass[12pt]{book}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[dvips]{graphicx}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{latexsym}
\usepackage{makeidx}
\usepackage{verbatim}

\newcommand{\complex}{\Bbb C}
\newcommand{\curl}{\nabla \times}
\renewcommand{\div}{\nabla \cdot}
\newcommand{\Dal}{\Box}
\newcommand{\nextline}{\\}
\newcommand{\breakline}{\\}
\newcommand{\grad}{\nabla}
\newcommand{\reals}{\Bbb R}
\newcommand{\tr}{\mbox{tr}}
\newcommand{\qed}{$\Box$}


%
% htex commands for images, links, and code
%
\newcommand{\img}[2]{\begin{center}\includegraphics[width=#2]{#1.eps}\end{center}}
\newcommand{\link}[2]{\href{#1}{#2}}
\newcommand{\insertcode}[1]{{\footnotesize \verbatiminput{#1}}}
\newcommand{\html}[1]{}
\newcommand{\latexorhtml}[2]{#1}

%
% Special chapter commands, so htex can construct headers and table
% of contents
%
\newcommand{\frontchapter}[3]{\chapter*{#1}}
\newcommand{\mainchapter}[3]{\chapter{#1}}
\newcommand{\backchapter}[3]{\chapter*{#1}}




\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}


\DefineVerbatimEnvironment{bash}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{pseudocode}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{python}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{text}{Verbatim}{fontsize=\small}

\newcounter{exercise}[chapter]
\renewcommand\theexercise{\thechapter.\arabic{exercise}}

\newenvironment{singlespace}{\renewcommand{\baselinestretch}{1}}

\newenvironment{exercise}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{exercises}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}


\newcommand{\problemheader}{\vspace{5mm} \noindent \textbf{\Large \!\!
    Problems}}

\newcounter{problem}[chapter]
\renewcommand\theproblem{\thechapter.\arabic{problem}}

\newenvironment{problem}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{problems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{myproblem}[chapter]
\renewcommand\themyproblem{\thechapter.\arabic{myproblem}}

\newenvironment{myproblems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@myproblem\themyproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem for the author
                        \refstepcounter{myproblem}\themyproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{request}[chapter]
\renewcommand\therequest{\thechapter.\arabic{request}}

\newenvironment{request}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@request\therequest}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Question to readers
                        \refstepcounter{request}\therequest:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{mycomment}[chapter]
\renewcommand\themycomment{\thechapter.\arabic{mycomment}}

\newenvironment{mycomments}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@mycomment\themycomment}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Comment for the author
                        \refstepcounter{mycomment}\themycomment:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{example}[chapter]
\renewcommand\theexample{\thechapter.\arabic{example}}

\newenvironment{examples}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@example\theexample}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Example
                        \refstepcounter{example}\theexample:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\DefineVerbatimEnvironment{myverbatim}{Verbatim}{fontsize=\small}


\makeindex

\begin{document}

\title{Beyond Bitcoin}
\author{Michael Nielsen\thanks{Email: mn@michaelnielsen.org}$^{,}$\thanks{Web: http://michaelnielsen.org/}}
\date{\today}

\maketitle

\pagestyle{headings}
\pagenumbering{roman}

\tableofcontents

\chapter{How Bitcoin actually works}

%
% Background
%
Many thousands of articles have been written purporting to explain
Bitcoin, the online, peer-to-peer currency.  Most of those articles
give only a brief account of the underlying cryptographic protocol,
and omit many details.  Even those articles which delve deeper often
gloss over crucial points.  My aim in this post is to explain all the
major ideas behind the Bitcoin protocol in a clear, easily
comprehensible way.

%
% this all sounds like hard work
%
Understanding the protocol is hard work.  It is tempting instead to
take Bitcoin as given, and to engage in speculation about how to get
rich with Bitcoin, whether Bitcoin is a bubble, whether Bitcoin might
one day mean the end of taxation, and so on.  That's fun, but severely
limits your understanding.  Understanding the details of the Bitcoin
protocol opens up otherwise inaccessible vistas.  It makes it possible
to understand how Bitcoin can be used to create new types of financial
instrument, and how, in turn, those financial instruments can be used
to enable new markets and new forms of collective human behaviour.
Talk about fun!

%
% What you need as background
%
I'll describe how Bitcoin can be used to create new types of financial
instrument in future posts.  This post, however, is about the
nuts-and-bolts of Bitcoin.  To understand the post, you need to be
comfortable with
\link{http://en.wikipedia.org/wiki/Public-key_cryptography}{public key
  cryptography}, and with the closely related idea of
\link{https://en.wikipedia.org/wiki/Digital_signature}{digital
  signatures}.  I'll also assume you're familiar with
\link{https://en.wikipedia.org/wiki/Cryptographic_hash_function}{cryptographic
  hashing}.  None of this is especially difficult.  The basic ideas
can be taught in freshman university mathematics or computer science
classes.  The ideas are beautiful, so if you're not familiar with
them, I recommend taking a few hours to get familiar.

%
% why does Bitcoin involve so much cryptography
%
It may seem surprising that Bitcoin's basis is cryptography.  Isn't
Bitcoin a currency, not a way of sending secret messages?  But the
problems that Bitcoin needs to solve are largely about securing
transactions -- making sure people can't steal from one another, or
impersonate one another, and so on.  In the world of atoms we achieve
security with devices such as locks, safes, signatures, and bank
vaults.  In the world of bits we achieve this kind of security with
cryptography.  And that's why Bitcoin is at heart a cryptographic
protocol.

My strategy in the article is to build Bitcoin up in stages.  I'll
begin by explaining a very simple digital currency, based on ideas
that are almost obvious.  We'll call that currency \emph{Infocoin}, to
distinguish it from Bitcoin.  Of course, our first version of Infocoin
will have many deficiencies, and so we'll go through several
iterations of Infocoin, with each iteration introducing one simple new
idea. After several iterations, we'll arrive at the full Bitcoin
protocol.  We will have reinvented Bitcoin!

This approach to explanation takes more time than if I explained the
entire Bitcoin protocol in one shot.  But while you can understand the
mechanics of Bitcoin through such a one-shot explanation, it's
difficult to understand \emph{why} Bitcoin is designed the way it is.
The advantage of the slower iterative approach is that it gives us a
really sharp understanding of why each element of Bitcoin is the way
it is.

\section{First steps: a signed letter of intent}

So how can we design a digital currency?  

On the face of it, a digital currency sounds impossible.  Let's
suppose someone --- we'll call her Alice --- wants to use a digital
currency.  If Alice can use a string of bits as money, how can we
prevent Alice from using the same bit string over and over, thus
minting for herself an infinite supply of money?  And how can we
prevent Bob or someone else forging such strings of bits, and using
that to steal from Alice?

These are just two of the many problems that must be overcome in order
to use information as currency.

As a first version of Infocoin, let's find a way that Alice can use a
string of bits as a (very primitive) form of money, in a way that
gives her at least some protection against forgery.  To do this, Alice
writes down the message "I, Alice, am giving Bob one Infocoin".  She
then digitally signs the message using a private cryptographic key,
and announces the signed string of bits to the entire world.

This isn't terribly impressive as a prototype for a digital currency!
But it does achieve two neat things.  First, anyone in the world
(including Bob) can then use Alice's public key to verify that Alice
really did sign the message "I, Alice, am giving Bob one Infocoin".
This establishes that Alice truly intends to give Bob one Infocoin.

Second, the procedure gives Alice some limited protection from
forgery.  The reason is that only Alice has the private key used to
sign the message.  That means it's not possible for someone else,
starting from scratch, to compose such a signed message. Of course,
after Alice has published her message it's possible for other people
to duplicate the message, so in that sense forgery is possible.  It's
a bit like forging a conventional physical signature --- it can be
done if you already have an original of someone's signature, but
there's simply no way you can forge it if you've never even seen the
signature.

To put this in a slightly different way, suppose someone encounters
the signed message ``I, Alice, am giving Bob one Infocoin''.  If they
verify the signature, then they know that at some point Alice signed
that message.  True, someone else might have since duplicated it, but
the initial act of construction must have been by Alice; no-one else
has Alice's private key, and so no-one else could have 

By the way, and just to be totally explicit, I should address the
question: what's the digital money here?  Well, it's just the message
itself: the ``I, Alice, am giving Bob one Infocoin'', digitally signed
by Alice.  This will remain true in more elaborate protocols --- all
our forms of digital money will be just more and more elaborate
messages (with a surrounding protocol for all parties to agree on a
transaction).

That's version 1 of Infocoin.  It's got many problems, and it's also
somewhat vague at the moment --- for example, I haven't addressed .
Over the next few sections we will identify and address those
problems, and also (again, gradually) make the vaguer elements
precise.  But we should also keep carefully in mind our current wins:
the protocol establishes that Alice truly intends to give Bob one
Infocoin; and it offers Alice some limited protection from forgery.

\section{Using serial numbers to make coins unique}

A problem with the first version of Infoin is that Alice could keep
sending Bob the same signed message over and over.  Suppose Alice
sends the signed message "I, Alice, am giving Bob one Infocoin" ten
times.  Does that mean Alice sent Bob ten \emph{different} Infocoins?
Was her message accidentally duplicated?  Perhaps she was trying to
trick Bob into believing that she had given him ten different
Infocoins, when the message only proves to the world that she intends
to transfer one Infocoin.

What we'd like is a way of making Infocoins unique.  They need a label
or serial number.  Alice would sign the message "I, Alice, am giving
Bob one Infocoin, with serial number 8740348".  Then, later, Alice
could sign the message "I, Alice, am giving Bob one Infocoin, with
serial number 8770431", and Bob (and everyone else) would know that
that this was a \emph{different} Infocoin that was being transferred.

I haven't yet said where Alice would get the serial numbers from.
Should she just make them up?  Obviously, that'd be convenient for her
-- she'd have the capacity to print money!  And we'd still have the
problem that she could spend a coin with the same serial number twice,
just by spending it with two different people.

One way to solve these problems is to introduce a \emph{bank} which is
the ultimate source of Infocoins.  This bank provides serial numbers,
keeps track of who has which Infocoins, and verifies that transactions
really are legitimate, preventing Alice from making up serial numbers
of her own.

In more detail, let's suppose Alice goes into the bank, and says "I
want to withdraw one Infocoin from my account".  The bank reduces her
account balance by one Infocoin, and gives her a new, never-before
used serial number, let's say 1234567.  Then, when Alice wants to
transfer an Infocoin to Bob, she'd sign the message "I, Alice, am
giving Bob one Infocoin, with serial number 1234567".  But Bob doesn't
just accept the Infocoin.  Instead, he contacts the bank, and verifies
that: (a) the Infocoin with that serial number belongs to Alice; and
(b) Alice hasn't already spent the Infocoin.  If both those things are
true, then Bob accepts the Infocoin, and the bank updates their
records to show that the Infocoin with that serial number is now in
Bob's possession, and no longer belongs to Alice.

\section{Making everyone collectively the bank}

This last solution looks pretty good.  It's still got problems --
problems like how to authenticate the identities of Alice, Bob and the
bank -- but it doesn't seem like a stretch to believe that with some
further work we could eliminate those problems.

However, it turns out that we can do something much more ambitious.
We can actually eliminate the bank from the protocol.  This changes
the nature of the currency considerably.  It means that there is no
longer a single organization in charge of the currency.

The idea is to make it so \emph{everyone} is the bank.  In particular,
we'll assume that everyone using Infocoin keeps a complete record of
which Infocoins belong to which person.  You can think of this as a
ledger showing all transactions.  We'll call this ledger the
\emph{block chain}, since that's what the complete record will be
called in Bitcoin, once we get to it.

Now, suppose Alice wants to transfer an Infocoin to Bob.  She signs
the message "I, Alice, am giving Bob one Infocoin, with serial number
1234567", and gives the signed message to Bob.  Bob can use his copy
of the block chain to check that, indeed, the coin is Alice's to give.
If that checks out then he can broadcast both Alice's message and his
acceptance of the transaction to the entire network, and everyone will
update their copy of the block chain.

We still have the ``where do serial number come from'' problem, but
I'm going to defer that to later, in the discussion of Bitcoin.  A
more significant problem is that this protocol allows Alice to cheat
by double spending her Infocoin.  She sends the signed message ``I,
Alice, am giving Bob one Infocoin, with serial number 1234567'' to
Bob, and the message``I, Alice, am giving Charlie one Infocoin, with
[the same] serial number 1234567'' to Charlie.  Both Bob and Charlie
use their block chain to verify that the Infocoin is Alice's to spend.
In both cases it checks out, and they each broadcast their acceptance
of the transaction (and Alice's signed messages).  How then should
other people update their block chains?  And even if everyone can
agree on a consistent way to update their block chains, there is still
the problem that either Bob or Charlie will be cheated.

Now, at first glance this seems like it would be difficult for Alice
to pull off.  After all, if Alice sends the message first to Bob, then
Bob can verify it, and tell everyone else in the network (including
Charlie) to update their block chain.  Once that has happened, Charlie
would no longer be fooled by Alice. So there is most likely only a
brief period of time in which Alice can double spend.  However, it's
obviously undesirable to have such a period of time.  Worse, there are
things Alice could do to make that period longer.  She could, for
example, use internet traffic analysis to find times when Bob and
Charlie are likely to have a lot of latency in communication, or
perhaps do something to deliberately disrupt their communications.  If
she can slow communication even a little that makes her task of double
spending significantly easier.

How can we address the problem of double spending?  The obvious
solution is that when Alice sends Bob an Infocoin, Bob shouldn't try
to verify the transcation alone.  Rather, he should broadcast the
possible transaction to the entire network of Infocoin users, and ask
them to help determine whether the transaction is legitimate.  If they
collectively decide that the transaction is okay, then Bob can accept
the Infocoin, and everyone will update their block chain
appropriately.  This type of protocol could help prevent double
spending, since if Alice tries to spend her Infocoin with both Bob and
Charlie, other people on the network will notice, and network users
will tell both Bob and Charlie that there is a problem with the
transaction, and the transaction shouldn't go through.

In more detail, let's suppose Alice wants to give Bob an Infocoin.  As
before, she signs the message "I, Alice, am giving Bob one Infocoin,
with serial number 1234567", and gives the signed message to Bob.
Also as before, Bob does a sanity check, using his copy of the block
chain to check that, indeed, the coin is Alice's to give.  But at that
point the protocol is modified.  Bob doesn't just go ahead and accept
the transaction.  Instead, he broadcast Alice's message to the entire
network.  Other members of the network check to see whether Alice
does, in fact, have that Infocoin to give Bob.  If so, then they
broadcast out the message "Yes, Alice does have Infocoin 1234567, it
can now be transferred to Bob.''  Once enough people have broadcast
that message, everyone updates their block chain to show that Infocoin
1234567 now belongs to Bob, and the transaction is complete.

This protocol is somewhat imprecise as I've just explained it.  For
instance, what does it mean to say ``once enough people have broadcast
that message''?  What does ``enough'' mean here?  It can't mean
everyone in the network, since we don't \emph{a priori} know who is in
the network.  For the same reason, it can't even mean some fixed
fraction of users in the network.  I'm not going to try to make this
precise right now.  Instead, in the next section I'll point out a
serious problem with the approach as described.  We'll fix the
problem, and in the process make the ideas above both better, and also
more specific.

\section{Proof-of-work}

Suppose Alice wants to double spend in the protocol I've just
described.  She could try to do this by taking over the Infocoin
network.  Let's suppose she uses an automated system to set up a large
number, let's say a billion, of separate identities on the Infocoin
network.  As before, she tries to double spend the same Infocoin with
both Bob and Charlie.  But when Bob and Charlie ask the network to
validate their respective transactions, Alice's sock puppet identities
swamp the network, announcing to Bob that they've validated his
transaction, and to Charlie that they've validated his transaction.

There's a clever way of avoiding this problem, using an idea known as
\emph{proof-of-work}.  The idea is counterintuitive and somewhat
complex: the basic idea is to (artificially) make it \emph{hard} for
network users to validate transactions, but to \emph{reward} them for
doing so.  The reward means that people on the network will still try
to help validate transactions, even though that's now quite a
difficult process.  The benefit of making it difficult to validate
transactions is that it is very unlikely that anyone will try to
impersonate a billion people on the network, since they'd need to
solve a million puzzles, and that will cost them more than it's worth.

XXX --- If that's really true, then why not both (a) participate in
the mining (and get the reward), and (b) try to cheat?  

That's the gist.  But to really understand proof-of-work, we need to
go through the details.

Suppose Alice broadcasts to the network the news that "I, Alice, am
giving Bob one Infocoin, with serial number 1234567".  

As other people on the network hear the message, they add it to a
queue of pending transactions that they've been told about, but which
haven't yet been approved by the network.  For instance, another
network user named David might have the following queue of pending
transactions:

I, Tom, am giving Sue one Infocoin, with serial number 1201174.

I, Sydney, am giving Cynthia one Infocoin, with serial number 1295618.

I, Alice, am giving Bob one Infocoin, with serial number 1234567.

David checks his ledger, and can see that each transaction is valid.
He would like to help out by broadcasting the validity to the entire
network.  

However, he can't just do that.  Instead, as part of the validation
protocol, David has to solve a hard computational puzzle.  Without the
solution to that puzzle, the network won't accept his validation of
the transaction.  

What puzzle does David need to solve?  To explain that, let $h$ be a
fixed hash function known by everyone in the network --- it's built
into the protocol.  Bitcoin uses the well-known
\link{https://en.wikipedia.org/wiki/SHA-2}{SHA-256} hash function.
Let's label David's queue of pending transactions with the label $l$,
just so it's got a name we can refer to.  The puzzle David has to
solve --- the proof-of-work --- is to find a number $x$ (called the
\emph{nonce}) such that when we append $x$ to $l$ and hash the
combination (output is in hexadecimal),
\begin{eqnarray}
  h(lx) = \mbox{1312af178c...}
\end{eqnarray}
the output hash begins with a string containing many zeroes.  In the
example above, drawn from the
\link{https://en.bitcoin.it/wiki/Proof_of_work}{Bitcoin wiki}, we've
used $l = $ ``Hello, world!'', i.e., not a genuine list of
transactions, just a string used for illustrative purposes, and a
candidate nonce, $x = 0$.  This gives, in full:
\begin{eqnarray}
  h("Hello, world!0") = 
  \mbox{1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64}
\end{eqnarray}
This is a failed attempt to find the nonce, since the output doesn't
begin with a long string of zeroes.  Trying $x = 1$ doesn't work much
better:
\begin{eqnarray}
h("Hello, world!1") = \mbox{e9afc424b79e4f6ab42d99c81156d3a17228d6e1eef4139be78e948a9332a7d8}
\end{eqnarray}
You can keep trying different values for the nonce.  Finally, at $x =
4250$ we obtain:
\begin{eqnarray}
  h("Hello, world!4250") = \mbox{0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9}
\end{eqnarray}
This nonce gives us a string of four zeroes in the output of the hash.

What makes this puzzle hard to solve is the fact that the output from
a (good) cryptographic hash function behaves like a random number:
change the input, even a tiny bit, and the output from the hash
function changes completely, in a way that's very hard to predict.  So
if we want the output hash value to begin with 10 zeroes, say, then
David will need to try something like $16^{10} \approx 10^{12}$
different values for $x$ before he finds a suitable nonce.  That's
actually a pretty challenging task, requiring lots of computational
power.

Obviously, it's possible to make this puzzle more or less difficult to
solve by requring fewer or more zeroes in the output from the hash
function.  I'll explain later how the Bitcoin protocol automatically
adjusts this difficulty.

Alright, let's suppose David is lucky and finds a suitable nonce, $x$.
Celebration!  (He'll be rewarded as described below).  He then
broadcasts the list of transactions he's approving to the network,
together with the value for $x$.  Other participants in the Infocoin
network can verify that $x$ is a valid solution to the proof-of-work
puzzle.  And they then update their block chains to reflect the new
transactions.

In this scheme, we're basically having a competition to approve
transactions.  Each entry in the competition costs a little bit of
computing power.  Provided a large number of people are entering the
competition, then a dishonest entrant, Alice, has only a small chance
to corrupt the process, unless she expends a huge amount of computing
resources.  That's likely to cost more than it's worth to her to
double spend, unless she's double spending a large number of
Infocoins.

\section{Reward for work, and the origin of Infocoins}

As I mentioned above, in order for proof-for-work to work well,
network users such as David need to be given an incentive to help
validate transactions.  If they're not, then they have no reason to
expend valuable computational power, merely to help validate other
people's transactions.  And if network users such as David are not
willing to expend that power, then the whole system falls apart.

The solution to this problem is to reward people who help validate
transactions.  In particular, suppose we credit whoever successfully
validates a block of transactions by crediting them with some
Infocoins.  Provided the Infocoin reward is large enough that will
give them an incentive to participate in validation.  In Bitcoin, this
validation process is called \emph{mining}.

Of course, this gives rise to many questions.  How much reward is
enough to persuade people to mine?  How does the change in supply of
Infocoins affect the Infocoin economy?  Does Infocoin mining end up in
concentrated in the hands of a few, or many?  If it's just a few,
doesn't that endanger the security of the system?  We'll look at these
questions below in the context of Bitcoin.

XXX --- I haven't emphasized enough the concept of blocks.  Or the
fact that the block chain is linearly ordered.

\section{Bitcoin}

Alright, we've now understood the main ideas behind BitCoin.  Let's
move away from Infocoin, and describe the actual BitCoin protocol.
There are a few new ideas here, but with one exception (discussed
below) they're mostly obvious modifications to Infocoin.

You install a wallet program on your computer.  To give you a sense of
what that means, here's a screenshot of a wallet program called
\link{https://multibit.org/}{Multbit}.  You can see the Bitcoin
balance -- a measly 2 dollars and 18 cents -- and a recent
transaction, depositing that 2 dollars and 18 cents:
% 
\img{images/wallet_transaction}{400px}
%
Suppose you're a merchant who has set up an online store, and you've
decided to allow people to pay using Bitcoin.  What you do is tell
your wallet program to generate a \emph{Bitcoin address}.  To do this,
it first generates a public / private key pair, and then it hashes the
public key to form your Bitcoin address:
%
\img{images/bitcoin_address}{400px}
%
You then send your Bitcoin address to the person who wants to buy from
you.  You could do this in email, or even put the address up publicly
on a webpage.  This is safe, since the address is merely a hash of
your public key, which is intended to be known by the world anyway.
(I'll return later to the question of why the Bitcoin address is a
hash, and not just the public key.)

The person who is going to pay you then generates a
\emph{transaction}.  Let's take a look at the raw data from an
\link{http://blockexplorer.com/tx/7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9}{actual
  transaction} transferring $0.31900000$ bitcoins.  I've added line
numbers, for ease of reference in the explanation below, but otherwise
this all the data in the transaction.
\begin{Verbatim}[fontsize=\small]
1.  {"hash":"7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9",
2.  "ver":1,
3.  "vin_sz":1,
4.  "vout_sz":1,
5.  "lock_time":0,
6.  "size":224,
7.  "in":[
8.    {"prev_out":
9.      {"hash":"2007aec728a1b1dcd36aa476e873926c412e94b2d16d060a7c97014b83a00c3e",
10.      "n":0},
11.    "scriptSig":"304502205014856cdf89da70ad9a4f223bac4e5477da5c6cb69ef2b9f8b5f8548e21307e0221009bfe2698f1eb1c561f41981d8e78c11d9e685a70e682f144ee6c8ab5ecb0497c01 042b2d8def903dd62d0c4161ed8d4ccfa5967e11a28e65cb141235b7c27d8ef6aa3bd63be077323cf3d7e0e8895b264b94feb4b40478b431da6f45dfc8e1004f62"}],
12. "out":[
13.   {"value":"0.31900000",
14.    "scriptPubKey":"OP_DUP OP_HASH160 a7db6ff121871c65a8924b8e40f160d385515ad7 OP_EQUALVERIFY OP_CHECKSIG"}]}
\end{Verbatim}

Let's go through this, line by line.

Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.

Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.

Lines 3 and 4 tell us that the transaction has one input and one
output, respectively.  I'll talk below about transactions with more
inputs and outputs, and why that's useful. 

Line 5 contains the value for \verb|lock_time|, which can be used to
control when a transaction is finalized.  For most Bitcoin
transactions being carried out (at least today) the \verb|lock_time|
is set to 0, which means the transaction is finalized immediately.

Line 6 tells us the size (in bytes) of the transaction.  Note that
it's not the monetary amount being transferred!  That comes later.

Lines 7 through 11 define the input to the transaction.  In
particular, lines 8 through 10 tell us that the input is to be taken
from the ouput from an earlier transaction, with the given
\verb|hash|.  The \verb|n=0| tells us it's to be the first output from
that transaction; we'll see soon how multiple outputs (and inputs)
from a transaction work, so don't worry too much about this for now.
Line 11 contains the signature of the person sending the money,
followed by a space, and then the corresponding public key.  Note that
the signature is for the data in lines 8 through 10.  In other words,
you can think of this as a signed message from the person sending the
money, saying where the funds are to come from.

One thing to note about the input is that there's nothing explicitly
specifying how many bitcoins from the previous transaction should be
spent in this transaction.  In fact, \emph{all} the bitcoins from the
\verb|n=0|th output of the previous transaction are.  So, for example,
if the \verb|n=0|th output of the earlier transaction was 2 bitcoins,
then 2 bitcoins will be spent in this transaction.  This is obviously
inconvenient --- like trying to buy bread with a 20 dollar note, and
not being able to break the note down.  The solution, of course, is
for the recipient to provide change.  This can be done using
transactions with multiple inputs and outputs, which we'll discuss in
the next section.

Lines 12 through 14 define the output from the transaction.  In
particular, line 13 tells us the value of the output, 0.39000000
bitcoins.  Line 14 is somewhat complicated.  The main thing to note is
that the long string "a7db6ff12..." is the Bitcoin address of the
intended recipient of the funds.  In fact, Line 14 is actually an
expression in Bitcoin's scripting language, of which more soon.

You can now see, by the way, how Bitcoin addresses the question I
raised earlier: where do Bitcoin serial numbers come from?  In fact,
the role of the serial number is played by transaction hashes.  In the
transaction above, for example, the recipient is receiving 0.39
Bitcoins, which come out of the first output of an earlier transaction
with hash 2007aec728$\ldots$ (line 9).  If you go and look in the
block chain for that transaction, you'd see that its output comes from
a still earlier transaction.  And so on.  

In fact, it's possible to keep following the chain of transactions.
Ultimately, of course, this must terminate.  This can happen in one of
two ways.  The first possibilitity is that you'll arrive at the very
first Bitcoin transaction, contained in the so-called
\link{https://en.bitcoin.it/wiki/Genesis_block}{Genesis block}.  This
is a special transaction, having no inputs, but a 50 Bitcoin output.
In other words, this transaction establishes an initial money supply.
The Genesis block is treated separately by Bitcoin clients, so

The second possibility is that you'll arrive at a so-called coinbase
transaction.  With the exception of the Genesis block, every block of
transactions in the block chain starts with a special coinbase
transaction.  This is the transaction rewarding the miner who
validated that block of transactions.  It uses a similar but not
identical format to the transaction above.  I won't go through it in
detail, but if you want to see an example, see
\link{http://blockexplorer.com/rawtx/c3facb1e90fdbaf0ee59e342a00e1c82588af138784fabad7398eb9dab3a0e5a}{here}.

There are two clever things about using transaction hashes instead of
serial numbers.  First, in Bitcoin there's not really any separate,
persistent ``coins'' at all, just a long series of transactions in the
block chain.  It's a clever idea to realize that you don't need
persistent coins, and can just get by with a ledger of transactions.
Second, by operating in this way we remove the need for any central
authority issuing serial numbers.  Instead, the serial numbers can be
self-generated, merely by hashing the transaction.

XXX --- I need to talk about at what level of detail I'm going to
specify things.

XXX --- I need to explain satoshis

\section{Transactions with multiple inputs and outputs}

In the last section I described how a transaction with just a single
input and a single output works.

In practice, it's often extremely convenient to create Bitcoin
transactions with multiple inputs or multiple outputs.

I'll take below about why this can be useful.  But it's actually
pretty easy to understand the details of how such a transaction works.
Here's the raw data from an
\link{http://blockexplorer.com/tx/99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f}{actual
  transaction}.  I've added line numbers, for ease of reference in the
explanation below, but otherwise this all the data in the transaction.

\begin{Verbatim}[fontsize=\small]
1. {"hash":"99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f",
2. "ver":1,
3. "vin_sz":3,
4.  "vout_sz":2,
5.  "lock_time":0,
6.  "size":552,
7.  "in":[
8.    {"prev_out":{
9.      "hash":"3beabcb8818f8331dd8897c2f837a4f6fe5cc5e0f3a7c8806319402d2467c30a",
10.        "n":0},
11.     "scriptSig":"3044022062ea95519d5d91cbce4086a63b8cd509a4900ba59063b69286236527e31a228e022076de59315406b7ec3a7414c98b5d32f47d11b9a786d31cf44883f3fb5812aa4001 04c7d24c58ae83f38bd2fb496758ff544965d58e7e5471ccb7349c8c404c64d0a57b562a20dfdcf152e0a401473ba520e387bf2516a4841a5f5bf5701b6fc09552"},
12.    {"prev_out":{
13.        "hash":"fdae9b76f974a9476f81c52d5ae1fbbd48cb840722e0805e56de1f9d2da0d9bc",
14.        "n":0},
15.      "scriptSig":"304502201c08b87eec72c4cb77369da7ef108ac18f29a67dff8865163cac3b155a0e9bf4022100afd61ce024ed33c4eee5e2f5cbc13203527a3b708f14c9573943132c061f800301 026e15a0c21d5f8c708e8b86d2f57ab1b7d31afee4a479e30af29d705532cf59ce"},
16.    {"prev_out":{
17.        "hash":"20c86b709ff4747866ef9f59788d1e18de81956c6501854a15707ccaa11076ce",
18.        "n":1},
19.      "scriptSig":"3044022038203b996b306916848732679b320be3c511870249da5b03a719f5a1f39cf646022070fd8c34a6ff73ebc8272e5ba717b9d3ef7100846bdbe4049808683d475d478001 038a52383beaf9711915f338f9c063332f39443358c1e4bc942da69551093b0896"}],
20.  "out":[
21.    {"value":"0.01068000",
22.      "scriptPubKey":"OP_DUP OP_HASH160 e8c306229529009d596689cb9212d6519cf6de8a OP_EQUALVERIFY OP_CHECKSIG"},
23.    {"value":"4.00000000",
24.      "scriptPubKey":"OP_DUP OP_HASH160 d644e36b9b295b3a1fa6ca2f816ba1f9340f4806 OP_EQUALVERIFY OP_CHECKSIG"}]}
\end{Verbatim}

Let's go through this, line by line.  Many of the lines are similar to
the single-input-single-output transaction, so I will only explain
those briefly.

Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.

Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.

Lines 3 and 4 tell us that the transaction has three inputs and two
outputs, respectively.

Line 5 contains the \verb|lock_time|.  As in the
single-input-single-output case this is set to 0, which means the
transaction is finalized immediately.

Line 6 tells us the size of the transaction in bytes.

Lines 7 through 19 define a list of the inputs to the transaction.
These are outputs from previous Bitcoin transactions.

The first input is defined in lines 8 through 11.  

In particular, lines 8 through 10 tell us that the input is to be
taken from the $n=0$th output from an earlier transaction, with the
given \verb|hash|.  Line 11 contains the signature, followed by a
space, and then the public key of the person sending the money.  Note
that the signature is for the data in lines 8 through 10.

Lines 12 through 15 define the second input, with a similar format to
lines 8 through 11.  And lines 16 through 19 define the third input.

Lines 20 through 24 define a list containing the two outputs from the
transaction.

The first output is defined in lines 21 and 22.  Line 21 tells us the
value of the output, 0.01068000 bitcoins.  As before, line 22 is an
expression in Bitcoin's scripting language.  The main thing to take
away here is that the string "e8c30622..." is the Bitcoin address of
the intended recipient of the funds.

The second output is defined lines 23 and 24, with a similar format to
the first output.

We can now see how the idea of change is implemented in Bitcoin.
Suppose, for example that I want to send you 150 satoshis.  I can do
so by spending spending money from a previous transaction in which I
received 200 satoshis.  Of course, I don't want to send you the entire
200 satoshis.  The solution is to send you 150 satoshis, and to send
one of my own Bitcoin addresses 50 satoshis.  Those 50 satoshis are
the change.  Of course, it differs a little from ordinary change,
since change is what you pay yourself.  But the net effect is the
same.

As a general principle, the sum of all the inputs in a transaction
must be at least as much as the sum of all the outputs.  This holds
for all Bitcoin transactions, except in the Genesis block, and in
coinbase transactions, both of which add to the overall Bitcoin
supply.

If the inputs sum up to more than the outputs, then the excess is used
as a \emph{transaction fee}.  This is paid to whichever miner
successfully validates the block which the current transaction is a
part of.

We've almost completed a basic description of the main ideas behind
Bitcoin.  However, there are a few loose ends to be tied up ---
questions you might reasonably have about the protocol as described.
So lets address those.

\section{Why not use a public key as a Bitcoin address, rather than a
  hash of the public key?}

This is a real oddity.  So far as I have been able to determine it
seems to be an arbitrary design decision.

One seemingly plausible explanation is that it's to add extra
security.  Even if the public key cryptosystem were broken, having
only hashed public keys public would still provide some level of
security.

Unfortunately, this story isn't especially plausible.  It's true that
to receive money, you only need reveal your Bitcoin address.  But to
spend money, you need to reveal your public key, since it's used to
sign the transaction.  Once you've revealed your public key, people
can take the hash to recover your address, and to see what previous
transactions it's participated in, as a recipient of funds.

In other words, your public key is kept secret only up to the point
where you actually spend the money you've received.

There is one scenario in which the use of addresses makes sense.
Suppose that the public key cryptography apocalypse occurs -- someone
discovers how to crack the public key cryptosystem.  Then everyone
whose public keys are known would immediately have their account
compromised.

Now, suppose that people never used the same Bitcoin address twice to
receive funds.

So provided you never use the same Bitcoin address twice

It's pretty common advice to  

\section{Why isn't the transaction as a whole signed?}


That completes a basic description of the main ideas behind Bitcoin.
Of course, there are many omitted details --- this isn't a formal
specification.  But I have described all the main ideas behind the
most common use cases for Bitcoin.

\section{Conclusion}

While the rules of Bitcoin are simple and easy to understand, that
doesn't mean that it's easy to understand all the consequences of the
rules.  There is vastly more that could be said about Bitcoin, and
I'll have several several future posts I'll investigate some of these
issues.

For now, though, I want to address just a few final issues.  Two are
oddities in the 

IN a later post I will explain the scripting system.  I will also
explain how Bitcoin scripting can be used as a platform to experiment
with all sorts of amazing financial instruments.  We'll see, for
example, how it can be used to do a type of
Kickstarter-at-the-protocol level...

\textbf{Is Bitcoin secure?}  It's difficult to say.  Bitcoin is a
relatively new protocol, and it's possible that scrutiny may find Many
of the key underlying technologies are relatively well tested --- the
hash functions used

\textbf{How anonymous is Bitcoin?} Many people claim that Bitcoin can
be used anonymously.  This claim has led to the formation of
marketplaces such as XXX, which specialize in illegal goods.  However,
it would it seems extremely unlikely that Bitcoin offers anything like
anonymity.  The block chain is public, meaning that it's possible for
anyone to see every Bitcoin transaction ever.  In that sense, Bitcoin
is the most open and transparent financial instrument the world has
ever seen.  Computer scientists have done a
\link{http://scholar.google.com/scholar?q=de-anonymization}{lot of
  work} figuring out how to de-anonymize social networks.





Note that not everyone in the Bitcoin network actually participates in
mining.


Remarkably, this includes even the
\link{http://bitcoin.org/bitcoin.pdf}{original paper} introducing
Bitcoin, which was vague at a number of key points, a vagueness only .

\end{document}



\section{How much should care about getting rid of the bank?}

XXX --- Why should we care?  Should we care?


\emph{If you enjoyed this essay, you may like to follow \link{XXX}{my
    blog} or \link{XXX}{follow me on Twitter}.  You might also like my
  XXX.}

\end{document}



\textbf{A note on analysing protocols such as Bitcoin:} Before we get
into an analysis of this protocol, a word on how to think about
cryptographic protocols.  Such protocols often have many problems --
in the context of digital money, that means multiple ways in which
people can cheat, forge money, steal money, and so on.  It's easy to
become overwhelmed by all the problems, and to think that you need to
look for a silver bullet solution which solves all the problems at
once.  This makes it difficult to think clearly about the protocol.

A better way to proceed is to concentrate on just one or two problems
at a time, and to ignore all other issues.  That's what we'll do.  At
each stage I'll identify just one or two problems, and then introduce
one or two simple ideas that solve that problem or problems.  Then
we'll do this over again, identifying a problem and a solution,
repeating this pattern several times, as we gradually build up the
protocol.

As we go through this process you'll likely have many thoughts about
(often glaring) holes in the protocol-of-the-moment.  You'll have to
trust that I will eventually resolve all those problems!  To build
confidence, I suggest keeping notes as you go -- if something's
bugging you, then pause in your reading, and write down as clearly as
posssible what's bugging you.  Don't worry about resolving the problem
immediately, just keep a record.  When you finally understand the
entire protocol, revisit your list, and see if the problem has been
addressed.

XXX - How to read crypto.  More generally, reading cryptography is
difficult work.  You certainly can't read it quickly, likely a novel.
But you can't even read it somewhat more slowly, as you might read a
conventional technical document.  Cryptographic protocols tend to be a
bit like puzzles, with interlocking parts put very carefully put
together.  To really understand them you need to examine all those
connections carefully, looking at them from many difficult angles, and
gradually getting to the point that it's all in your head at once.
That's tough work, but, as with a well-designed puzzle, there is also
a beauty to it, once you get the entirety of the protocol inside your
head, and understand how all the parts relate.




What ideas do I want to add?


XXX: MODIFICATION: Modify by replacing the serial number by a pointer
to the previous transaction.

Modifications: not everyone needs to have a copy of the block chain.




Make it take constant time.


CHEATING: WORK VERY HARD TO 

</div>






The transaction is labelled by a hash.  This is a hash of parts of the
remainder of the transaction.  It's not completely clear to me which
parts; apparently the transaction is somewhat malleable because of
this, but the amounts being paid out, senders and recipients can't be
changed.

A transaction actually doesn't have just one sender and receiver, but
can potentially involve many parties. 


Number of inputs.

Number of outputs.

Each input contains: (1) The hash of (part of) a previous transaction;
(2) an index for an output in that transaction; (3) the public key of
the sender; and (4) a signature for (part of) the transaction.



Each output contains: (1) The value for that output; (2) The hashed
public key of the intended recipient.

Note that the sum of the output values must equal the sum of the
inputs.

Why does it contain the hashed public key of the intended recipient?
I don't really quite get this.


Comment on the author: The paper is not especially well written.  It
contains a number of vague statements, and some <em>non
sequiturs</em>.  It looks to me most likely to be the work of someone
very bright, and very well informed, but probably not a long-time
professional.  It wouldn't surprise, though, if they were a graduate
student in the field, or had equivalent background.




How does Bitcoin relate to karma systems?


The dull questions:

+

The privacy premium.




Good questions: When it is economic to invest in Bitcoins?

What is the impact of having a fixed supply of money?


The economics of privacy.  

Will people pay a privacy premium?




This results in the growth of



What problem is proof of work solving?


The supply of money.  The Bitcoin addresses responsible for validating
the block receives a reward.  This reward is carried out as the first
transaction in the block.




Kickstarter at the protocol level


Generalized eminent domain


Anonymity?  Probably never.  The problem is that too much of the graph
is known.  Can always de-anonymize.  Might we hide steganographically?
Idea is to create a large number of transactions which swamp the
signal from the small number.

DDoS the Bitcoin network.  Simply start creating a very large number
of transactions.  This will overcome the network's ability to verify.
It wouldn't take a very large amount of power.



<h3>Problem: concentration of Bitcoin mining power in the hands of a
few</h3>

Consider what happens over time.  There's a good incentive to spend
more and more money.

Well, what happens at that point?  

It depends.  Suppose someone can apply ingenuity 

the problem is that, eventually, you'd expect
the cost of mining to .  You'd actually expect the number of pople

People switch their mining setups on and off, depending on the current
exchange rate.

You see this happening already.  

Rushes occur.


It's conventional to use uppercase Bitcoin when talking about general
aspects of Bitcoin.  So we'll talk about the Bitcoin protocol, the
Bitcoin foundation, and so on.  And to use lowercase bitcoin when
referring to specific denominations, as in "She sent 5 bitcoins to pay
for her order."

The name "Bitcoin" makes it sound as though a bitcoin is a
diminunitive unit of currency.  In fact, as I write a single bitcoin
trades for about 200 US dollars, and the exchange rate has in the past
gone nearly as high as 240 US dollars.  If Bitcoin were ever to go
truly mainstream I have little doubt the exchange rate would go much
higher.  And so a bitcoin isn't diminutive at all, it's big dollars.

In actual fact, the bitcoin isn't the basic unit of currency.  A
single bitcoin can be split up into 100 million "satoshis", named
after the originator of Bitcoin,
\link{https://en.bitcoin.it/wiki/Satoshi_Nakamoto}{Satoshi Nakamoto}.
If 200 US dollars is one bitcoin, then a satoshi is 1/500th of a US
cent.  

Bitcoin is the Wild West.  There's all sorts of shady behaviour and
hucksters looking to make a quick buck.  It's also true that, as in
the gold rush, it may be better to make money selling shovels than
digging for gold.  One oddity is that you'll read a lot of online
accounts by people who seem very knowledgeable and utterly confident
-- and who turn out to be completely wrong.  Sometimes this is
indicative of shady behaviour.  But more often it's just routine
over-confidence.  Don't believe everything you read.


\chapter{Scripting in Bitcoin}

In Douglas Adams's ``Hitchiker's Guide to the Galaxy'' books, one of
the characters tells the protagonist, Arthur, ``The insurance business
is completely screwy now.  You know they've reintroduced the death
penalty for insurance company directors'' ``Really'', says
Arthur. ``No, I didn't.  For what offense?''  The other character
frowns and replies ``What do you mean, offense?''

It's not a bad line, at least if you're not an insurance company
director.  There's a natural tension between people who buy insurance,
and people who sell insurance.  But if we step back from our self
interest a bit, then we can appreciate how marvellous an invention
insurance is.  The first modern insurance contract was made in the
port of Genoa in 1343.  At the time, merchant shipping was incredibly
expensive and risky, and few individuals could bear the risk of
funding an expedition.  Maritime insurance helped spread the risk, and
made it much easier for people to fund expeditions.  The idea spread
rapidly through seafaring Europe, helping enable the great age of
exploration, and the first wave of globalization.  It was an example
of a financial instrument which enabled people to co-ordinate with one
enough in new ways, and thus opened up new forms of collective
behaviour.

Like insurance, Bitcoin is a new type of financial instrument.  Also
like insurance, Bitcoin has the capacity to

This is where the interesting innovation will happen.  Two ways: (1)
By services based on scripting (clients, in particular); (2)

There is also 


Bitcoin address shortener.


You may wonder why the script is split into two parts.  The reason is
that Bitcoin transactions can involve many inputs and many outputs.
Each input needs XXX, while each output XXX.

\section{Why anonymity and untraceability?}

%
% why anonymity and untraceability?
%
Many Bitcoin fans make a big deal out of the relative anonymity and
difficulty of tracing Bitcoin.  What makes anonymity and
untraceability desirable in a currency?

The obvious reason a person might want anonymity and untraceability is
if they plan to do something illegal.  Online marketplaces such as
\link{https://en.wikipedia.org/wiki/Silk_Road_(marketplace)}{Silk
  Road}, \link{XXX}{XXX}, and \link{XXX}{XXX} use Bitcoin to make it
possible to buy and sell illegal drugs, XXX, XXX, and many other
illegal items and services.

Enabling this kind of crime is not a good argument in favour of
Bitcoin!  However, there is a better argument to be made.  Control
over currency gives a government power.  We see this, for example, in
the way the US State Department and other organizations
\link{https://en.wikipedia.org/wiki/WikiLeaks#U.S._diplomatic_cables_leak_responses}{put
  pressure on Wikileaks} by getting organizations such as PayPal and
MasterCard to freeze accounts owned by WikiLeaks.  Now, if you dislike
WikiLeaks this may not seem like such a bad thing.  But it's not
difficult to imagine variations on this which would be unequivocally
bad.  In the early 1990s, human rights groups in the Sudan had their
assets frozen, and in some cases confiscated, by an unfriendly
government.  Such examples suggest that a citizenry is safest if
government control over currency is minimized, except in the case of a
compelling interest.  One way of minimizing that control is make a
currency anonymous and untraceable.


ECONOMICS OF MINING: I don't think it's at all clear what the long-run
value of Bitcoin mining is.  It's a complicated problem.  What are the
tradeoffs involved in setting up an equilibrium?

Let's suppose the (appropriately amortized) cost of mining a bitcoin
is less than a bitcoin.  (There should be a risk premium, too.)

The equilibrium: 



Will effective banks still re-emerge?  What's the difference between a
marketplace / exchange and a bank, anyway?



The boostrapping problem in describing a currency.  When you write
about a currency such as Bitcoin there's an inherent oddity.  There's
always a point at which the description of the currency stops.



For a currency with so much emphasis on security, Bitcoin is amusingly
insecure.  In principle it has been designed with security in mind.
But it's attracted a considerable number of scammers looking to
get-rich-quick secure.  the nature of the users it has attracted is
such that it's

\chapter{The Bitcoin scripting language}


\chapter{Bitcoin as a two-layer protocol}

The Bitcoin protocol combines two abilities:

(1) The ability to maintain a global, distributed, public,
authenticated, write-only ledger, to which arbitrary (signed) messages
can be written by any member of the Bitcoin network.

(2) The ability to parse and act on messages in the ledger, treating
them as a generalization of our traditional notion of money.

At the moment Bitcoin intertwines these two abilities.  Bitcoin would
be made more powerful if these two abilities were pulled apart into
two separate protocols:

(1) A \emph{ledger protol} implementing a global, distributed, public,
authenticated, write-only ledger, to which arbitrary (signed) messages
can be written by any member of the Bitcoin network.

(2) Building on top of the ledger protocol, a separate \emph{payment
  protocol} for parsing and acting on the messages in the ledger.

These two protocols together could easily be used to reimplement the
existing Bitcoin protocol.  The reason for separating the protocols is
that the ledger protocol would be, in its own right, an extremely
powerful capability.  Many other protocols could be built on top of
this capability, protocols that implement very different functionality
from Bitcoin.

The proposal I'm making is similar to the way the
\link{https://en.wikipedia.org/wiki/Internet_protocol_suite}{internet
  protocol} is divided into (relatively) separate layers taking care
of separate functionality.  For example, there is a link layer which
takes care of local network behaviour.  Built on top of that is the
internet layer, which enables packets of data to be moved between
remote hosts.  And on top of that are the transport and application
layers, which have separate functionalities again.

This division of the internet protocol into separate layers has
enabled the internet to support many different applications ---
everything from the web to email to World of Warctaft.  I believe that
separating out the ledger protocol in a clean way would have a similar
impact, opening up the development of many other applications.  Quite
aside from the technical implications,


\section{Planning}

+ How Bittorrent works.

+ Matching theorems.

+ Why not just chip companies doing mining?  If it's profitable...

\end{document}