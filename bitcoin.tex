%
% 7658
%
\documentclass[12pt]{book}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[dvips]{graphicx}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage{latexsym}
\usepackage{makeidx}
\usepackage{verbatim}

\newcommand{\complex}{\Bbb C}
\newcommand{\curl}{\nabla \times}
\renewcommand{\div}{\nabla \cdot}
\newcommand{\Dal}{\Box}
\newcommand{\nextline}{\\}
\newcommand{\breakline}{\\}
\newcommand{\grad}{\nabla}
\newcommand{\reals}{\Bbb R}
\newcommand{\tr}{\mbox{tr}}
\newcommand{\qed}{$\Box$}


%
% htex commands for images, links, and code
%
\newcommand{\img}[2]{\begin{center}\includegraphics[width=#2]{#1.eps}\end{center}}
\newcommand{\link}[2]{\href{#1}{#2}}
\newcommand{\insertcode}[1]{{\footnotesize \verbatiminput{#1}}}
\newcommand{\html}[1]{}
\newcommand{\latexorhtml}[2]{#1}

%
% Special chapter commands, so htex can construct headers and table
% of contents
%
\newcommand{\frontchapter}[3]{\chapter*{#1}}
\newcommand{\mainchapter}[3]{\chapter{#1}}
\newcommand{\backchapter}[3]{\chapter*{#1}}




\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}


\DefineVerbatimEnvironment{bash}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{pseudocode}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{python}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{text}{Verbatim}{fontsize=\small}

\newcounter{exercise}[chapter]
\renewcommand\theexercise{\thechapter.\arabic{exercise}}

\newenvironment{singlespace}{\renewcommand{\baselinestretch}{1}}

\newenvironment{exercise}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{exercises}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@exercise\theexercise}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Exercise
                        \refstepcounter{exercise}\theexercise:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}


\newcommand{\problemheader}{\vspace{5mm} \noindent \textbf{\Large \!\!
    Problems}}

\newcounter{problem}[chapter]
\renewcommand\theproblem{\thechapter.\arabic{problem}}

\newenvironment{problem}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newenvironment{problems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@problem\theproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem
                        \refstepcounter{problem}\theproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{myproblem}[chapter]
\renewcommand\themyproblem{\thechapter.\arabic{myproblem}}

\newenvironment{myproblems}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@myproblem\themyproblem}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Problem for the author
                        \refstepcounter{myproblem}\themyproblem:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{request}[chapter]
\renewcommand\therequest{\thechapter.\arabic{request}}

\newenvironment{request}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@request\therequest}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Question to readers
                        \refstepcounter{request}\therequest:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{mycomment}[chapter]
\renewcommand\themycomment{\thechapter.\arabic{mycomment}}

\newenvironment{mycomments}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@mycomment\themycomment}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Comment for the author
                        \refstepcounter{mycomment}\themycomment:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\newcounter{example}[chapter]
\renewcommand\theexample{\thechapter.\arabic{example}}

\newenvironment{examples}{
            \vspace{0.7cm}
            \begin{singlespace} \vspace{-0.8cm}
            \def\@currentlabel{\p@example\theexample}
            \begin{list}{}{%
                \renewcommand{\makelabel}[1]{%
                    {\sl\bf Example
                        \refstepcounter{example}\theexample:~\hfill}%
                    \ifthenelse{\equal{##1}{}}{}{
                        ({\bf ##1})
                    }%
                }%
                \setlength{\leftmargin}{1cm}
            }%
        }%
        {\end{list}\end{singlespace}\vspace{0.1cm}}

\DefineVerbatimEnvironment{myverbatim}{Verbatim}{fontsize=\small}


\makeindex

\begin{document}

\title{Beyond Bitcoin}
\author{Michael Nielsen\thanks{Email: mn@michaelnielsen.org}$^{,}$\thanks{Web: http://michaelnielsen.org/}}
\date{\today}

\maketitle

\pagestyle{headings}
\pagenumbering{roman}

\tableofcontents

\chapter{How Bitcoin actually works}

%
% what I do in this article
%
This article explains in detail how the Bitcoin protocol works.  Of
course, many thousands of articles ``explaining'' Bitcoin have been
written.  Most of these articles are superficial, giving only a vague
account of the underlying cryptographic ideas, and omitting many
details.  Even those articles which delve deeper often gloss over
crucial points.  Remarkably, this includes even the
\link{http://bitcoin.org/bitcoin.pdf}{original paper} introducing
Bitcoin, which was vague at a number of key points.  My aim in this
article is to present all the major ideas behind the Bitcoin protocol
in a clear, comprehensible way.

%
% this all sounds like hard work
%
Understanding the protocol is hard work.  It is tempting to instead
take Bitcoin as given, and to engage in speculation about how to get
rich with Bitcoin, whether Bitcoin is a bubble, whether it means the
end of taxation, and so on.  That's fun, but severely limits your
understanding.  Understanding the details of the Bitcoin protocol
opens up otherwise inaccessible vistas.  It makes it possible to
understand how Bitcoin can be used to create new types of financial
instrument, and, in turn, how those financial instruments can be used
to enable new forms of collective human behaviour.  Talk about fun!

%
% What you need as background
%
To understand this post, you'll need to be comfortable with
\link{http://en.wikipedia.org/wiki/Public-key_cryptography}{public key
  cryptography}, and with the closely related idea of
\link{https://en.wikipedia.org/wiki/Digital_signature}{digital
  signatures}.  I'll also assume you're familiar with
\link{https://en.wikipedia.org/wiki/Cryptographic_hash_function}{cryptographic
  hashing}.  None of this is especially difficult.  The basic ideas
can be taught in freshman university mathematics or computer science
classes.  The ideas are beautiful, so if you're not familiar with
them, I recommend taking a few hours to get familiar.

%
% why does Bitcoin involve so much cryptography
%
It may seem surprising that Bitcoin's basis is cryptography.  Isn't
Bitcoin a form of currency, not a way of sending secret messages?  But
the problems that need to be solved to make Bitcoin work are largely
about securing transactions -- making sure people can't steal from one
another, that one person can't impersonate another, and so on.  In the
world of atoms we achieve security with devices such as locks, safes,
bank vaults, and security guards.  In the digital world this kind of
security is achieved through cryptography.  And that's why Bitcoin is
at heart a cryptographic protocol.

\section{First steps: a signed letter of intent}

So how can we design a digital currency?  

At first, digital currency sounds impossible.  If Alice can use a
string of bits as money, how can we prevent Alice from using the same
bit string over and over, thus minting an infinite supply of money for
herself?  And how can we prevent Bob or someone else forging such
strings of bits, effectively stealing from Alice?

These are just two of the many problems that need to be overcome in
order to use information as currency.

Now, at this point I could explain the entire Bitcoin protocol in one
shot, up-front.  It'd be relatively straightforward for you to
understand the mechanics of the protocol, and you could understand how
it solves the problems described above.  But while you'd understand
the mechanics of the protocol, you wouldn't understand in any deep way
\emph{why} Bitcoin is designed the way it is.

For that reason, I'm instead going to build Bitcoin up in stages.
I'll begin by explaining a very simple digital currency, based on
ideas that are almost obvious.  We'll call that currency
\emph{Infocoin}, to distinguish it from Bitcoin.  Of course, our first
version of Infocoin will have many deficiencies!  We'll go through
several iterations of Infocoin, with each iteration introducing one
new idea.  This approach takes considerably longer than explaining
Bitcoin in one shot, but the payoff is a deeper understanding of the
full Bitcoin protocol.  In a sense we'll rediscover Bitcoin.

Alright, as a first step, let's address one of the problems I
mentioned above: let's find a way that Alice can use a string of bits
as (very primitive form of) money, without allowing anyone else to
forge that string, and thus steal from Alice.  To do this, Alice
writes down the message "I, Alice, am giving Bob one Infocoin".  She
then digitally signs the message using a private cryptographic key,
and announces the signed string of bits to the entire world.

This isn't terribly impressive as a prototype for a digital currency!
But it does achieve two things.  First, anyone in the world (including
Bob) can then use Alice's public key to verify that Alice really did
sign the message "I, Alice, am giving Bob one Infocoin".  This
establishes that Alice truly intends to give Bob one Infocoin.

Second, the procedure gives Alice at least some limited protection
from forgery.  The reason is that only Alice has the private key used
to sign the message.  Of course, once Alice has published her message
it's possible for other people to duplicate the message, so in that
sense forgery is possible.  But before that initial act of
publication, there's no way someone else can forge that bit string.

To put this in a slightly different way, suppose someone encounters
the signed message ``I, Alice, am giving Bob one Infocoin''.  If they
verify the signature, then they know that at some point Alice signed
that message.  True, someone else might have since duplicated it, but
the initial act of construction must have been by Alice; no-one else
has Alice's private key, and so no-one else could have 

By the way, and just to be totally explicit, I should address the
question: what's the digital money here?  Well, it's just the message
itself: the ``I, Alice, am giving Bob one Infocoin'', digitally signed
by Alice.  This will remain true in more elaborate protocols --- all
our forms of digital money will be just more and more elaborate
messages (with a surrounding protocol for all parties to agree on a
transaction).

That's version 1 of Infocoin.  It's got many problems, and it's also
somewhat vague at the moment --- for example, I haven't addressed .
Over the next few sections we will identify and address those
problems, and also (again, gradually) make the vaguer elements
precise.  But we should also keep carefully in mind our current wins:
the protocol establishes that Alice truly intends to give Bob one
Infocoin; and it offers Alice some limited protection from forgery.

\section{Using serial numbers to make coins unique}

A problem with the first version of Infoin is that Alice could keep
sending Bob the same signed message over and over.  Suppose Alice
sends the signed message "I, Alice, am giving Bob one Infocoin" ten
times.  Does that mean Alice sent Bob ten \emph{different} Infocoins?
Was her message accidentally duplicated?  Perhaps she was trying to
trick Bob into believing that she had given him ten different
Infocoins, when the message only proves to the world that she intends
to transfer one Infocoin.

What we'd like is a way of making Infocoins unique.  They need a label
or serial number.  Alice would sign the message "I, Alice, am giving
Bob one Infocoin, with serial number 8740348".  Then, later, Alice
could sign the message "I, Alice, am giving Bob one Infocoin, with
serial number 8770431", and Bob (and everyone else) would know that
that this was a \emph{different} Infocoin that was being transferred.

I haven't yet said where Alice would get the serial numbers from.
Should she just make them up?  Obviously, that'd be convenient for her
-- she'd have the capacity to print money!  And we'd still have the
problem that she could spend a coin with the same serial number twice,
just by spending it with two different people.

One way to solve these problems is to introduce a \emph{bank} which is
the ultimate source of Infocoins.  This bank provides serial numbers,
keeps track of who has which Infocoins, and verifies that transactions
really are legitimate, preventing Alice from making up serial numbers
of her own.

In more detail, let's suppose Alice goes into the bank, and says "I
want to withdraw one Infocoin from my account".  The bank reduces her
account balance by one Infocoin, and gives her a new, never-before
used serial number, let's say 1234567.  Then, when Alice wants to
transfer an Infocoin to Bob, she'd sign the message "I, Alice, am
giving Bob one Infocoin, with serial number 1234567".  But Bob doesn't
just accept the Infocoin.  Instead, he contacts the bank, and verifies
that: (a) the Infocoin with that serial number belongs to Alice; and
(b) Alice hasn't already spent the Infocoin.  If both those things are
true, then Bob accepts the Infocoin, and the bank updates their
records to show that the Infocoin with that serial number is now in
Bob's possession, and no longer belongs to Alice.

\section{Making everyone collectively the bank}

This last solution looks pretty good.  It's still got problems --
problems like how to authenticate the identities of Alice, Bob and the
bank -- but it doesn't seem like a stretch to believe that with some
further work we could eliminate those problems.

However, it turns out that we can do something much more ambitious.
We can actually eliminate the bank from the protocol.  This changes
the nature of the currency considerably.  It means that there is no
longer a single organization in charge of the currency.

The idea is to make it so \emph{everyone} is the bank.  In particular,
we'll assume that everyone using Infocoin keeps a complete record of
which Infocoins belong to which person.  You can think of this as a
ledger showing all transactions.  We'll call this ledger the
\emph{block chain}, since that's what the complete record will be
called in Bitcoin, once we get to it.

Now, suppose Alice wants to transfer an Infocoin to Bob.  She signs
the message "I, Alice, am giving Bob one Infocoin, with serial number
1234567", and gives the signed message to Bob.  Bob can use his copy
of the block chain to check that, indeed, the coin is Alice's to give.
If that checks out then he can broadcast both Alice's message and his
acceptance of the transaction to the entire network, and everyone will
update their copy of the block chain.

We still have the ``where do serial number come from'' problem, but
I'm going to defer that to later, in the discussion of Bitcoin.  A
more significant problem is that this protocol allows Alice to cheat
by double spending her Infocoin.  She sends the signed message ``I,
Alice, am giving Bob one Infocoin, with serial number 1234567'' to
Bob, and the message``I, Alice, am giving Charlie one Infocoin, with
[the same] serial number 1234567'' to Charlie.  Both Bob and Charlie
use their block chain to verify that the Infocoin is Alice's to spend.
In both cases it checks out, and they each broadcast their acceptance
of the transaction (and Alice's signed messages).  How then should
other people update their block chains?  And even if everyone can
agree on a consistent way to update their block chains, there is still
the problem that either Bob or Charlie will be cheated.

Now, at first glance this seems like it would be difficult for Alice
to pull off.  After all, if Alice sends the message first to Bob, then
Bob can verify it, and tell everyone else in the network (including
Charlie) to update their block chain.  Once that has happened, Charlie
would no longer be fooled by Alice. So there is most likely only a
brief period of time in which Alice can double spend.  However, it's
obviously undesirable to have such a period of time.  Worse, there are
things Alice could do to make that period longer.  She could, for
example, use internet traffic analysis to find times when Bob and
Charlie are likely to have a lot of latency in communication, or
perhaps do something to deliberately disrupt their communications.  If
she can slow communication even a little that makes her task of double
spending significantly easier.

How can we address the problem of double spending?  The obvious
solution is that when Alice sends Bob an Infocoin, Bob shouldn't try
to verify the transcation alone.  Rather, he should broadcast the
possible transaction to the entire network of Infocoin users, and ask
them to help determine whether the transaction is legitimate.  If they
collectively decide that the transaction is okay, then Bob can accept
the Infocoin, and everyone will update their block chain
appropriately.  This type of protocol could help prevent double
spending, since if Alice tries to spend her Infocoin with both Bob and
Charlie, other people on the network will notice, and network users
will tell both Bob and Charlie that there is a problem with the
transaction, and the transaction shouldn't go through.

In more detail, let's suppose Alice wants to give Bob an Infocoin.  As
before, she signs the message "I, Alice, am giving Bob one Infocoin,
with serial number 1234567", and gives the signed message to Bob.
Also as before, Bob does a sanity check, using his copy of the block
chain to check that, indeed, the coin is Alice's to give.  But at that
point the protocol is modified.  Bob doesn't just go ahead and accept
the transaction.  Instead, he broadcast Alice's message to the entire
network.  Other members of the network check to see whether Alice
does, in fact, have that Infocoin to give Bob.  If so, then they
broadcast out the message "Yes, Alice does have Infocoin 1234567, it
can now be transferred to Bob.''  Once enough people have broadcast
that message, everyone updates their block chain to show that Infocoin
1234567 now belongs to Bob, and the transaction is complete.

This protocol is somewhat imprecise as I've just explained it.  For
instance, what does it mean to say ``once enough people have broadcast
that message''?  What does ``enough'' mean here?  It can't mean
everyone in the network, since we don't \emph{a priori} know who is in
the network.  For the same reason, it can't even mean some fixed
fraction of users in the network.  I'm not going to try to make this
precise right now.  Instead, in the next section I'll point out a
serious problem with the approach as described.  We'll fix the
problem, and in the process make the ideas above both better, and also
more specific.

\section{Proof-of-work}

Suppose Alice wants to double spend in the protocol I've just
described.  She could try to do this by taking over the Infocoin
network.  Let's suppose she uses an automated system to set up a large
number, let's say a billion, of separate identities on the Infocoin
network.  As before, she tries to double spend the same Infocoin with
both Bob and Charlie.  But when Bob and Charlie ask the network to
validate their respective transactions, Alice's sock puppet identities
swamp the network, announcing to Bob that they've validated his
transaction, and to Charlie that they've validated his transaction.

There's a clever way of avoiding this problem, using an idea known as
\emph{proof-of-work}.  The idea is counterintuitive and somewhat
complex: the basic idea is to (artificially) make it \emph{hard} for
network users to validate transactions, but to \emph{reward} them for
doing so.  The reward means that people on the network will still try
to help validate transactions, even though that's now quite a
difficult process.  The benefit of making it difficult to validate
transactions is that it is very unlikely that anyone will try to
impersonate a billion people on the network, since they'd need to
solve a million puzzles, and that will cost them more than it's worth.

XXX --- If that's really true, then why not both (a) participate in
the mining (and get the reward), and (b) try to cheat?  

That's the gist.  But to really understand proof-of-work, we need to
go through the details.

Suppose Alice broadcasts to the network the news that "I, Alice, am
giving Bob one Infocoin, with serial number 1234567".  

As other people on the network hear the message, they add it to a
queue of pending transactions that they've been told about, but which
haven't yet been approved by the network.  For instance, another
network user named David might have the following queue of pending
transactions:

I, Tom, am giving Sue one Infocoin, with serial number 1201174.

I, Sydney, am giving Cynthia one Infocoin, with serial number 1295618.

I, Alice, am giving Bob one Infocoin, with serial number 1234567.

David checks his ledger, and can see that each transaction is valid.
He would like to help out by broadcasting the validity to the entire
network.  

However, he can't just do that.  Instead, as part of the validation
protocol, David has to solve a hard computational puzzle.  Without the
solution to that puzzle, the network won't accept his validation of
the transaction.  

What puzzle does David need to solve?  To explain that, let $h$ be a
fixed hash function known by everyone in the network --- it's built
into the protocol.  Bitcoin uses the well-known
\link{https://en.wikipedia.org/wiki/SHA-2}{SHA-256} hash function.
Let's label David's queue of pending transactions with the label $l$,
just so it's got a name we can refer to.  The puzzle David has to
solve --- the proof-of-work --- is to find a number $x$ (called the
\emph{nonce}) such that when we append $x$ to $l$ and hash the
combination (output is in hexadecimal),
\begin{eqnarray}
  h(lx) = \mbox{1312af178c...}
\end{eqnarray}
the output hash begins with a string containing many zeroes.  In the
example above, drawn from the
\link{https://en.bitcoin.it/wiki/Proof_of_work}{Bitcoin wiki}, we've
used $l = $ ``Hello, world!'', i.e., not a genuine list of
transactions, just a string used for illustrative purposes, and a
candidate nonce, $x = 0$.  This gives, in full:
\begin{eqnarray}
  h("Hello, world!0") = 
  \mbox{1312af178c253f84028d480a6adc1e25e81caa44c749ec81976192e2ec934c64}
\end{eqnarray}
This is a failed attempt to find the nonce, since the output doesn't
begin with a long string of zeroes.  Trying $x = 1$ doesn't work much
better:
\begin{eqnarray}
h("Hello, world!1") = \mbox{e9afc424b79e4f6ab42d99c81156d3a17228d6e1eef4139be78e948a9332a7d8}
\end{eqnarray}
You can keep trying different values for the nonce.  Finally, at $x =
4250$ we obtain:
\begin{eqnarray}
  h("Hello, world!4250") = \mbox{0000c3af42fc31103f1fdc0151fa747ff87349a4714df7cc52ea464e12dcd4e9}
\end{eqnarray}
This nonce gives us a string of four zeroes in the output of the hash.

What makes this puzzle hard to solve is the fact that the output from
a (good) cryptographic hash function behaves like a random number:
change the input, even a tiny bit, and the output from the hash
function changes completely, in a way that's very hard to predict.  So
if we want the output hash value to begin with 10 zeroes, say, then
David will need to try something like $16^{10} \approx 10^{12}$
different values for $x$ before he finds a suitable nonce.  That's
actually a pretty challenging task, requiring lots of computational
power.

Obviously, it's possible to make this puzzle more or less difficult to
solve by requring fewer or more zeroes in the output from the hash
function.  I'll explain later how the Bitcoin protocol automatically
adjusts this difficulty.

Alright, let's suppose David is lucky and finds a suitable nonce, $x$.
Celebration!  (He'll be rewarded as described below).  He then
broadcasts the list of transactions he's approving to the network,
together with the value for $x$.  Other participants in the Infocoin
network can verify that $x$ is a valid solution to the proof-of-work
puzzle.  And they then update their block chains to reflect the new
transactions.

In this scheme, we're basically having a competition to approve
transactions.  Each entry in the competition costs a little bit of
computing power.  Provided a large number of people are entering the
competition, then a dishonest entrant, Alice, has only a small chance
to corrupt the process, unless she expends a huge amount of computing
resources.  That's likely to cost more than it's worth to her to
double spend, unless she's double spending a large number of
Infocoins.

\section{Reward for work, and the origin of Infocoins}

As I mentioned above, in order for proof-for-work to work well,
network users such as David need to be given an incentive to help
validate transactions.  If they're not, then they have no reason to
expend valuable computational power, merely to help validate other
people's transactions.  And if network users such as David are not
willing to expend that power, then the whole system falls apart.

The solution to this problem is to reward people who help validate
transactions.  In particular, suppose we credit whoever successfully
validates a block of transactions by crediting them with some
Infocoins.  Provided the Infocoin reward is large enough that will
give them an incentive to participate in validation.  In Bitcoin, this
validation process is called \emph{mining}.

Of course, this gives rise to many questions.  How much reward is
enough to persuade people to mine?  How does the change in supply of
Infocoins affect the Infocoin economy?  Does Infocoin mining end up in
concentrated in the hands of a few, or many?  If it's just a few,
doesn't that endanger the security of the system?  We'll look at these
questions below in the context of Bitcoin.

\section{Bitcoin}

Alright, we've now understood the main ideas behind BitCoin.  Let's
move away from Infocoin, and describe the actual BitCoin protocol.

You install a wallet program on your computer.  To give you a sense of
what that means, here's a screenshot of a wallet program called
\link{https://multibit.org/}{Multbit}.  You can see the Bitcoin
balance -- a measly 2 dollars and 18 cents -- and a recent
transaction, depositing that 2 dollars and 18 cents:
% 
\img{images/wallet_transaction}{400px}
%
Suppose you're a merchant who has set up an online store, and you've
decided to allow people to pay using Bitcoin.  What you do is tell
your wallet program to generate a \emph{Bitcoin address}.  To do this,
it first generates a public / private key pair, and then it hashes the
public key to form your Bitcoin address:
%
\img{images/bitcoin_address}{400px}
%
You then send your Bitcoin address to the person who wants to buy from
you.  You could do this in email, or even put it up publicly on a
webpage.  This is quite safe -- after all, it's a hash of your public
key, which is intended to be known by the world, anyway.  (I'll return
later to the question of why we hash the public key to obtain the
Bitcoin address.)

The person who is going to pay you then generates a
\emph{transaction}.  Let's take a look at the raw data from an
\link{http://blockexplorer.com/tx/7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9}{actual
  transaction} transferring $0.31900000$ bitcoins.  I've added line
numbers, for ease of reference in the explanation below, but otherwise
this all the data in the transaction.
\begin{Verbatim}[fontsize=\small]
1.  {"hash":"7c402505be883276b833d57168a048cfdf306a926484c0b58930f53d89d036f9",
2.  "ver":1,
3.  "vin_sz":1,
4.  "vout_sz":1,
5.  "lock_time":0,
6.  "size":224,
7.  "in":[
8.    {"prev_out":
9.      {"hash":"2007aec728a1b1dcd36aa476e873926c412e94b2d16d060a7c97014b83a00c3e",
10.      "n":0},
11.    "scriptSig":"304502205014856cdf89da70ad9a4f223bac4e5477da5c6cb69ef2b9f8b5f8548e21307e0221009bfe2698f1eb1c561f41981d8e78c11d9e685a70e682f144ee6c8ab5ecb0497c01 042b2d8def903dd62d0c4161ed8d4ccfa5967e11a28e65cb141235b7c27d8ef6aa3bd63be077323cf3d7e0e8895b264b94feb4b40478b431da6f45dfc8e1004f62"}],
12. "out":[
13.   {"value":"0.31900000",
14.    "scriptPubKey":"OP_DUP OP_HASH160 a7db6ff121871c65a8924b8e40f160d385515ad7 OP_EQUALVERIFY OP_CHECKSIG"}]}
\end{Verbatim}

Let's go through this, line by line.

Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.

Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.

Lines 3 and 4 tell us that the transaction has one input and one
output, respectively.  I'll talk below about transactions with more
inputs and outputs, and why that's useful. 

Line 5 contains the value for \verb|lock_time|, which can be used to
control when a transaction is finalized.  For most Bitcoin
transactions being carried out (at least today) the \verb|lock_time|
is set to 0, which means the transaction is finalized immediately.

Line 6 tells us the size (in bytes) of the transaction.  Note that
it's not the monetary amount being transferred!  That comes later.

Lines 7 through 11 define the input to the transaction.  In
particular, lines 8 through 10 tell us that the input is to be taken
from the ouput from an earlier transaction, with the given
\verb|hash|.  The \verb|n=0| tells us it's to be the first output from
that transaction; we'll see soon how multiple outputs (and inputs)
from a transaction work, so don't worry too much about this for now.
Line 11 contains the signature, followed by a space, and then the
public key of the person sending the money.  Note that the signature
is for the data in lines 8 through 10. 

Lines 12 through 14 define the output from the transaction.  In
particular, line 13 tells us the value of the output, 0.39000000
bitcoins, or 39,000,000 satoshis.  Line 14 is somewhat complicated.
The main thing, however, is that the long string "a7db6ff12..." is the
Bitcoin address of the intended recipient of the funds.

ZZZ

You can now see, by the way, how Bitcoin addresses the serial number
issue.

\end{document}

\section{Transactions with multiple inputs and outputs}

I described above how a transaction with just a single input and a
single output works.

In practice, it's often extremely convenient to create Bitcoin
transactions with multiple inputs or multiple outputs.

For example, suppose I want to send you else 150 satoshis.  They do so
by spending money from a previous transaction in which they received
200 satoshis.  Of course, they don't want to send the entire 200
satoshis to the other person.  The solution is to send the other
person 150 satoshis, and to send one of their own Bitcoin addresses 50
satoshis.  Those 50 satoshis are known as <em>change</em>.  Of course,
it differs a little from ordinary change, since change is what you pay
yourself.




The second output is defined lines 23 and 24, with a similar format to
the first output.

The sum of all the inputs must be equal to the sum of all the outputs.

If not...XXX.  Transaction fee.


We can visualize the entire transaction content as follows:

XXX



Here's the raw data from an <a
href="http://blockexplorer.com/tx/99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f">actual
transaction</a>.  I've added line numbers, for ease of reference in
the explanation below, but otherwise this all the data in the
transaction.

\begin{Verbatim}[fontsize=\small]
1. {"hash":"99383066a5140b35b93e8f84ef1d40fd720cc201d2aa51915b6c33616587b94f",
2. "ver":1,
3. "vin_sz":3,
4.  "vout_sz":2,
5.  "lock_time":0,
6.  "size":552,
7.  "in":[
8.    {"prev_out":{
9.      "hash":"3beabcb8818f8331dd8897c2f837a4f6fe5cc5e0f3a7c8806319402d2467c30a",
10.        "n":0},
11.     "scriptSig":"3044022062ea95519d5d91cbce4086a63b8cd509a4900ba59063b69286236527e31a228e022076de59315406b7ec3a7414c98b5d32f47d11b9a786d31cf44883f3fb5812aa4001 04c7d24c58ae83f38bd2fb496758ff544965d58e7e5471ccb7349c8c404c64d0a57b562a20dfdcf152e0a401473ba520e387bf2516a4841a5f5bf5701b6fc09552"},
12.    {"prev_out":{
13.        "hash":"fdae9b76f974a9476f81c52d5ae1fbbd48cb840722e0805e56de1f9d2da0d9bc",
14.        "n":0},
15.      "scriptSig":"304502201c08b87eec72c4cb77369da7ef108ac18f29a67dff8865163cac3b155a0e9bf4022100afd61ce024ed33c4eee5e2f5cbc13203527a3b708f14c9573943132c061f800301 026e15a0c21d5f8c708e8b86d2f57ab1b7d31afee4a479e30af29d705532cf59ce"},
16.    {"prev_out":{
17.        "hash":"20c86b709ff4747866ef9f59788d1e18de81956c6501854a15707ccaa11076ce",
18.        "n":1},
19.      "scriptSig":"3044022038203b996b306916848732679b320be3c511870249da5b03a719f5a1f39cf646022070fd8c34a6ff73ebc8272e5ba717b9d3ef7100846bdbe4049808683d475d478001 038a52383beaf9711915f338f9c063332f39443358c1e4bc942da69551093b0896"}],
20.  "out":[
21.    {"value":"0.01068000",
22.      "scriptPubKey":"OP_DUP OP_HASH160 e8c306229529009d596689cb9212d6519cf6de8a OP_EQUALVERIFY OP_CHECKSIG"},
23.    {"value":"4.00000000",
24.      "scriptPubKey":"OP_DUP OP_HASH160 d644e36b9b295b3a1fa6ca2f816ba1f9340f4806 OP_EQUALVERIFY OP_CHECKSIG"}]}
\end{Verbatim}

Let's go through this, line by line.

Line 1 contains the hash of the remainder of the transaction.  This is
used as an identifier for the transaction.

Line 2 tells us that this is a transaction in version 1 of the Bitcoin
protocol.

Lines 3 and 4 tell us that the transaction has three inputs and two
outputs, respectively.

Line 5 is a detail.  It contains the value for \verb|lock_time|, which
can be used to control when a transaction is finalized.  In this case,
as for most transactions today, the <code>lock_time</code> is set to
0, which means the transaction is finalized immediately.

Line 6 tells us the size of the transaction.

Lines 7 through 19 define a list of the inputs to the transaction.
These are outputs from previous Bitcoin transactions.

The first input is defined in lines 8 through 11.  

In particular, lines 8 through 10 tell us that the input is to be
taken from the <code>n=0</code>th output from an earlier transaction,
with the given <code>hash</code>.  Line 11 contains the signature,
followed by a space, and then the public key of the person sending the
money.  Note that the signature is for the data in lines 8 through 10.

Lines 12 through 15 define the second input, with a similar format to
lines 8 through 11.  And lines 16 through 19 define the third input.

Lines 20 through 24 define a list containing the two outputs from the
transaction.

The first output is defined in lines 21 and 22.  Line 21 tells us the
value of the output, 0.01068000 bitcoins, or 1,068,000 satoshis.  Line
22 is somewhat complicated.  The main thing, however, is that the long
string "e8c30622..." is the Bitcoin address of the 

The second output is defined lines 23 and 24, with a similar format to
the first output.

The sum of all the inputs must be equal to the sum of all the outputs.

If not...XXX.  Transaction fee.

Suppose someone wants to send someone else 150 satoshis.  They do so
by spending money from a previous transaction in which they received
200 satoshis.  Of course, they don't want to send the entire 200
satoshis to the other person.  The solution is to send the other
person 150 satoshis, and to send one of their own Bitcoin addresses 50
satoshis.  Those 50 satoshis are known as <em>change</em>.  Of course,
it differs a little from ordinary change, since change is what you pay
yourself.

We can visualize the entire transaction content as follows:

XXX



Change.

\section{Oddities of Bitcoin}


Security.  How secure is it, really?  


Bitcoin has several oddities.

One oddity is the use of addresses.  Why not use the public key as the
address, rather than a hash of the public key?

This seems to be a fairly arbitrary design decision.  

One seemingly plausible explanation is that it's to add extra
security.  Even if the public key cryptosystem were broken, having
only hashed public keys public would still provide some level of
security.

Unfortunately, this story isn't especially plausible.  It's true that
to receive money, you only need reveal your Bitcoin address.  But to
spend money, you need to reveal your public key, since it's used to
sign the transaction.  Once you've revealed your public key, people
can take the hash to recover your address, and to see what previous
transactions it's participated in, as a recipient of funds.

In other words, your public key is kept secret


There is one scenario in which the use of addresses makes sense.
Suppose that the public key cryptography apocalypse occurs -- someone
discovers how to crack the public key cryptosystem.  Then everyone
whose public keys are known would immediately have their account
entirely compromised.  

Now, suppose that people never used the same Bitcoin address twice to
receive funds.

So provided you never use the same Bitcoin address twice

It's pretty common advice to  

A second oddity is that the transaction as a whole isn't signed.  XXX; TRANSACTION MALLEABILITY.


Note that not everyone in the Bitcoin network actually participates in
mining.



\section{How much should care about getting rid of the bank?}

XXX --- Why should we care?  Should we care?


\emph{If you enjoyed this essay, you may like to follow \link{XXX}{my
    blog} or \link{XXX}{follow me on Twitter}.  You might also like my
  XXX.}

\end{document}



\textbf{A note on analysing protocols such as Bitcoin:} Before we get
into an analysis of this protocol, a word on how to think about
cryptographic protocols.  Such protocols often have many problems --
in the context of digital money, that means multiple ways in which
people can cheat, forge money, steal money, and so on.  It's easy to
become overwhelmed by all the problems, and to think that you need to
look for a silver bullet solution which solves all the problems at
once.  This makes it difficult to think clearly about the protocol.

A better way to proceed is to concentrate on just one or two problems
at a time, and to ignore all other issues.  That's what we'll do.  At
each stage I'll identify just one or two problems, and then introduce
one or two simple ideas that solve that problem or problems.  Then
we'll do this over again, identifying a problem and a solution,
repeating this pattern several times, as we gradually build up the
protocol.

As we go through this process you'll likely have many thoughts about
(often glaring) holes in the protocol-of-the-moment.  You'll have to
trust that I will eventually resolve all those problems!  To build
confidence, I suggest keeping notes as you go -- if something's
bugging you, then pause in your reading, and write down as clearly as
posssible what's bugging you.  Don't worry about resolving the problem
immediately, just keep a record.  When you finally understand the
entire protocol, revisit your list, and see if the problem has been
addressed.

XXX - How to read crypto.  More generally, reading cryptography is
difficult work.  You certainly can't read it quickly, likely a novel.
But you can't even read it somewhat more slowly, as you might read a
conventional technical document.  Cryptographic protocols tend to be a
bit like puzzles, with interlocking parts put very carefully put
together.  To really understand them you need to examine all those
connections carefully, looking at them from many difficult angles, and
gradually getting to the point that it's all in your head at once.
That's tough work, but, as with a well-designed puzzle, there is also
a beauty to it, once you get the entirety of the protocol inside your
head, and understand how all the parts relate.




What ideas do I want to add?


XXX: MODIFICATION: Modify by replacing the serial number by a pointer
to the previous transaction.

Modifications: not everyone needs to have a copy of the block chain.


<h3>Why have a chain?</h3>

<div class="section">

Why have a chain?


Why point 

To approve the 

In particular, they actually have to solve a difficult puzzle before
they can approve a transaction.



when a potential transaction is broadcast



Make it take constant time.


CHEATING: WORK VERY HARD TO 

</div>






The transaction is labelled by a hash.  This is a hash of parts of the
remainder of the transaction.  It's not completely clear to me which
parts; apparently the transaction is somewhat malleable because of
this, but the amounts being paid out, senders and recipients can't be
changed.

A transaction actually doesn't have just one sender and receiver, but
can potentially involve many parties. 


Number of inputs.

Number of outputs.

Each input contains: (1) The hash of (part of) a previous transaction;
(2) an index for an output in that transaction; (3) the public key of
the sender; and (4) a signature for (part of) the transaction.



Each output contains: (1) The value for that output; (2) The hashed
public key of the intended recipient.

Note that the sum of the output values must equal the sum of the
inputs.

Why does it contain the hashed public key of the intended recipient?
I don't really quite get this.


Comment on the author: The paper is not especially well written.  It
contains a number of vague statements, and some <em>non
sequiturs</em>.  It looks to me most likely to be the work of someone
very bright, and very well informed, but probably not a long-time
professional.  It wouldn't surprise, though, if they were a graduate
student in the field, or had equivalent background.




How does Bitcoin relate to karma systems?


The dull questions:

+

The privacy premium.




Good questions: When it is economic to invest in Bitcoins?

What is the impact of having a fixed supply of money?


The economics of privacy.  

Will people pay a privacy premium?




This results in the growth of



What problem is proof of work solving?


The supply of money.  The Bitcoin addresses responsible for validating
the block receives a reward.  This reward is carried out as the first
transaction in the block.




Kickstarter at the protocol level


Generalized eminent domain


Anonymity?  Probably never.  The problem is that too much of the graph
is known.  Can always de-anonymize.  Might we hide steganographically?
Idea is to create a large number of transactions which swamp the
signal from the small number.

DDoS the Bitcoin network.  Simply start creating a very large number
of transactions.  This will overcome the network's ability to verify.
It wouldn't take a very large amount of power.



<h3>Problem: concentration of Bitcoin mining power in the hands of a
few</h3>

Consider what happens over time.  There's a good incentive to spend
more and more money.

Well, what happens at that point?  

It depends.  Suppose someone can apply ingenuity 

the problem is that, eventually, you'd expect
the cost of mining to .  You'd actually expect the number of pople

People switch their mining setups on and off, depending on the current
exchange rate.

You see this happening already.  

Rushes occur.


It's conventional to use uppercase Bitcoin when talking about general
aspects of Bitcoin.  So we'll talk about the Bitcoin protocol, the
Bitcoin foundation, and so on.  And to use lowercase bitcoin when
referring to specific denominations, as in "She sent 5 bitcoins to pay
for her order."

The name "Bitcoin" makes it sound as though a bitcoin is a
diminunitive unit of currency.  In fact, as I write a single bitcoin
trades for about 200 US dollars, and the exchange rate has in the past
gone nearly as high as 240 US dollars.  If Bitcoin were ever to go
truly mainstream I have little doubt the exchange rate would go much
higher.  And so a bitcoin isn't diminutive at all, it's big dollars.

In actual fact, the bitcoin isn't the basic unit of currency.  A
single bitcoin can be split up into 100 million "satoshis", named
after the originator of Bitcoin,
\link{https://en.bitcoin.it/wiki/Satoshi_Nakamoto}{Satoshi Nakamoto}.
If 200 US dollars is one bitcoin, then a satoshi is 1/500th of a US
cent.  

Bitcoin is the Wild West.  There's all sorts of shady behaviour and
hucksters looking to make a quick buck.  It's also true that, as in
the gold rush, it may be better to make money selling shovels than
digging for gold.  One oddity is that you'll read a lot of online
accounts by people who seem very knowledgeable and utterly confident
-- and who turn out to be completely wrong.  Sometimes this is
indicative of shady behaviour.  But more often it's just routine
over-confidence.  Don't believe everything you read.


\chapter{Scripting in Bitcoin}

In Douglas Adams's ``Hitchiker's Guide to the Galaxy'' books, one of
the characters tells the protagonist, Arthur, ``The insurance business
is completely screwy now.  You know they've reintroduced the death
penalty for insurance company directors'' ``Really'', says
Arthur. ``No, I didn't.  For what offense?''  The other character
frowns and replies ``What do you mean, offense?''

It's not a bad line, at least if you're not an insurance company
director.  There's a natural tension between people who buy insurance,
and people who sell insurance.  But if we step back from our self
interest a bit, then we can appreciate how marvellous an invention
insurance is.  The first modern insurance contract was made in the
port of Genoa in 1343.  At the time, merchant shipping was incredibly
expensive and risky, and few individuals could bear the risk of
funding an expedition.  Maritime insurance helped spread the risk, and
made it much easier for people to fund expeditions.  The idea spread
rapidly through seafaring Europe, helping enable the great age of
exploration, and the first wave of globalization.  It was an example
of a financial instrument which enabled people to co-ordinate with one
enough in new ways, and thus opened up new forms of collective
behaviour.

Like insurance, Bitcoin is a new type of financial instrument.  Also
like insurance, Bitcoin has the capacity to

This is where the interesting innovation will happen.  Two ways: (1)
By services based on scripting (clients, in particular); (2)

There is also 


Bitcoin address shortener.

\section{Why anonymity and untraceability?}

%
% why anonymity and untraceability?
%
Many Bitcoin fans make a big deal out of the relative anonymity and
difficulty of tracing Bitcoin.  What makes anonymity and
untraceability desirable in a currency?

The obvious reason a person might want anonymity and untraceability is
if they plan to do something illegal.  Online marketplaces such as
\link{https://en.wikipedia.org/wiki/Silk_Road_(marketplace)}{Silk
  Road}, \link{XXX}{XXX}, and \link{XXX}{XXX} use Bitcoin to make it
possible to buy and sell illegal drugs, XXX, XXX, and many other
illegal items and services.

Enabling this kind of crime is not a good argument in favour of
Bitcoin!  However, there is a better argument to be made.  Control
over currency gives a government power.  We see this, for example, in
the way the US State Department and other organizations
\link{https://en.wikipedia.org/wiki/WikiLeaks#U.S._diplomatic_cables_leak_responses}{put
  pressure on Wikileaks} by getting organizations such as PayPal and
MasterCard to freeze accounts owned by WikiLeaks.  Now, if you dislike
WikiLeaks this may not seem like such a bad thing.  But it's not
difficult to imagine variations on this which would be unequivocally
bad.  In the early 1990s, human rights groups in the Sudan had their
assets frozen, and in some cases confiscated, by an unfriendly
government.  Such examples suggest that a citizenry is safest if
government control over currency is minimized, except in the case of a
compelling interest.  One way of minimizing that control is make a
currency anonymous and untraceable.


ECONOMICS OF MINING: I don't think it's at all clear what the long-run
value of Bitcoin mining is.  It's a complicated problem.  What are the
tradeoffs involved in setting up an equilibrium?

Let's suppose the (appropriately amortized) cost of mining a bitcoin
is less than a bitcoin.  (There should be a risk premium, too.)

The equilibrium: 



Will effective banks still re-emerge?  What's the difference between a
marketplace / exchange and a bank, anyway?



The boostrapping problem in describing a currency.  When you write
about a currency such as Bitcoin there's an inherent oddity.  There's
always a point at which the description of the currency stops.



For a currency with so much emphasis on security, Bitcoin is amusingly
insecure.  In principle it has been designed with security in mind.
But it's attracted a considerable number of scammers looking to
get-rich-quick secure.  the nature of the users it has attracted is
such that it's

\chapter{The Bitcoin scripting language}


\chapter{Bitcoin as a two-layer protocol}

The Bitcoin protocol combines two abilities:

(1) The ability to maintain a global, distributed, public,
authenticated, write-only ledger, to which arbitrary (signed) messages
can be written by any member of the Bitcoin network.

(2) The ability to parse and act on messages in the ledger, treating
them as a generalization of our traditional notion of money.

At the moment Bitcoin intertwines these two abilities.  Bitcoin would
be made more powerful if these two abilities were pulled apart into
two separate protocols:

(1) A \emph{ledger protol} implementing a global, distributed, public,
authenticated, write-only ledger, to which arbitrary (signed) messages
can be written by any member of the Bitcoin network.

(2) Building on top of the ledger protocol, a separate \emph{payment
  protocol} for parsing and acting on the messages in the ledger.

These two protocols together could easily be used to reimplement the
existing Bitcoin protocol.  The reason for separating the protocols is
that the ledger protocol would be, in its own right, an extremely
powerful capability.  Many other protocols could be built on top of
this capability, protocols that implement very different functionality
from Bitcoin.

The proposal I'm making is similar to the way the
\link{https://en.wikipedia.org/wiki/Internet_protocol_suite}{internet
  protocol} is divided into (relatively) separate layers taking care
of separate functionality.  For example, there is a link layer which
takes care of local network behaviour.  Built on top of that is the
internet layer, which enables packets of data to be moved between
remote hosts.  And on top of that are the transport and application
layers, which have separate functionalities again.

This division of the internet protocol into separate layers has
enabled the internet to support many different applications ---
everything from the web to email to World of Warctaft.  I believe that
separating out the ledger protocol in a clean way would have a similar
impact, opening up the development of many other applications.  Quite
aside from the technical implications,


\section{Planning}

+ How Bittorrent works.

+ Matching theorems.

+ Why not just chip companies doing mining?  If it's profitable...

\end{document}